<html>
<head>
<meta http-equiv="Content-Language" content="ru">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>
Глава 1
</title>
</head>
<body BGCOLOR="#E7E3E7" TEXT="#000000" LINK="#004080" VLINK="#004080" Background=" ">
<font  face="Verdana, Arial, Helvetica, sans-serif"><table width="14%" border="0" cellspacing="0">
<tr>
<td width="9%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img src="Back.gif" border="0" width="73" height="22">
</a>
</font>
</td>
<td width="45%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="../index.html">
<img src="Menu.gif" border="0" width="73" height="22">
</a>
</font>
</td>
<td width="46%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img src="For.gif" border="0" lowsrc="Index4.htm" width="73" height="22">
</a>
</font>
</td>
</tr>
</table>
<P>
<font face="Verdana, Arial, Helvetica, sans-serif" size="4">
<b>
Аутентификация
</font></P>
</b>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Когда Антон проходит процедуру регистрации для получения доступа к глобальной 
компьютерной сети Internet, каким образом информационно-коммерческая служба, 
услугами которой он пользуется, узнает, что это именно 
Антон, а не Зиновий, пытающийся бесплатно (за счет Антона) попутешествовать по 
Всемирной паутине? Чаще всего эта проблема решается при помощи пароля: Антон 
должен ввести некую секретную информацию. известную только ему и его поставщику 
услуг Internet. Причем вводить эту информацию надо каждый раз при прохождении 
процедуры регистрации.
</font></p>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
<b>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Аутентификация при помощи однонаправленных функций
</font></p>
</b>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">На сервере, который проверяет правильность введенного Антоном пароля. 
совершенно не обязательно хранить пароли пользователей. Достаточно научить 
сервер отличать правильные пароли от неправильных. Это легко сделать При помощи 
однонаправленных функций. Тогда на сервере будут присутствовать не сами пароли, 
а их хэш-значения:
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">1. Антон посылает на сервер свой пароль.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">2. С помощью однонаправленной функции сервер вычисляет хэш-значение для 
присланного Антоном пароля.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">3. Сервер сравнивает вычисленное хэш-значение с эталоном, который хранится в 
его памяти, и делает вывод о правильности пароля Антона.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Поскольку при такой схеме аутентификации пользователей уже не требуется 
держать пароли на сервере, то опасаться, что кто-либо взломает защиту сервера и 
украдет файл с паролями, нет никаких причин. Список хэш-значений, 
соответствующих паролям зарегистрированных пользователей. совершенно бесполезен 
для Зиновия, т. к. найти пароль по его yjiii-значению путем обращения 
однонаправленной функции ему не удастся.
</font></p>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
<b>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Отражение словарной атаки при помощи &quot;изюминок&quot;
</font></p>
</b>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Файл с хэш-значениями, полученными из паролей, может подвергнуться словарной 
атаке. Составив словарь примерно из 1 млн самых распространенных паролей, 
Зиновий применит к ним хэш-функцию. В результате он получит файл объемом до 10 
Мбайт, который уместится на нескольких дне кетах. Далее Зиновий украдет с 
сервера файл с паролями, зашифрованными с помощью хэш-функции, и сравнит его со 
своим файлом, содержащим хэш-значения для самых часто используемых паролей. 
Совпадающие хэш-значения позволят Зиновию определить некоторые из паролей.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Отразить словарную атаку помогает введение в схему аутентификации 
зарегистрированных пользователей так называемых 
<i>
изюминок. 
</i>
&quot;Изюминка 
представляет собой случайную битовую строку, которая присоединяется к паролю 
прежде, чем к нему будет применена хэш-функция. Затем на сервере запоминается как вычисленное хэш-значение, так и соответствующая ему 
&quot;изюминка&quot;.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Если количество возможных &quot;изюминок&quot; достаточно велико, от словарной атаки 
мало толку. Зиновий должен будет вычислять хэш-значение не только для каждого 
пароля, но и для каждой &quot;изюминки&quot;. Смысл введения &quot;изюминок&quot; в схему 
аутентификации пользователей состоит в том. чтобы заставить злоумышленника 
совершать пробное шифрование всех паролей. входящих в составленный им словарь, 
каждый раз, когда он пытается вскрыть какой-либо отдельный пароль, вместо того 
чтобы заранее вычислить хэш-значения этих паролей, а затем просто сравнивать 
полученные значения с эталонными, украденными с сервера.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">&quot;Изюма&quot; понадобится много. Во многих версиях операционной системы UNIX 
используются &quot;изюминки&quot; длиной 12 бит. Этого явно недостаточно: существуют 
программы, которые при помогли словарной атаки позволяют за неделю вскрыть от 30 
до 40% всех паролей, применяемых пользователями UNIX.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Таким образом, схема аутентификации с &quot;изюминками&quot; не может служить панацеей. 
Она обеспечивает защиту только от словарной атаки всего файла с паролями, 
зашифрованными с помощью однонаправленной функции. Однако эта схема бессильна, 
когда мощной и слаженной атаке подвергается отдельный пароль конкретного 
пользователя.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Схема аутентификации с &quot;изюминками&quot; эффективна и тогда, когда при регистрации 
на разных серверах используется один и тот же пароль. Но если пароль плохой, 
лучше он все равно не станет, каким бы количеством &quot;изюма&quot; для его защиты вы ни 
запаслись.
</font></p>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
<b>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Периодическая сменяемость паролей
</font></p>
</b>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Даже при наличии &quot;изюминок&quot; схема аутентификации пользователей путем 
проверки их паролей имеет один очень серьезный недостаток. Ведь не исключено, 
что линия связи, соединяющая персональный компьютер Антона с сервером 
информационно-коммерческой службы, проходит по территориям 33-х стран, 
законодательство которых по-разному трактует права своих и иностранных граждан 
на сохранение в тайне их личной переписки. И поэтому узнать пароль Антона, в 
принципе, может любой, кто сумеет подключиться к этой линии связи или обратиться в память сервера и узнать пароль. 
прежде чем для него будет вычислено соответствующее хэш-значение. Чтобы 
уменьшить ущерб от компрометации пароля, его следует периодически менять. 
Делается это следующим образом.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Антон генерирует случайное число R и пересылает его серверу, который 
вычисляет, исходя из этого числа и однонаправленной функции f значения
<span lang="en-us">
x
</span>
<sub>
1
</sub>
=
<span lang="en-us">
</span>
f
<span lang="en-us">
</span>
(R), 
x
<sub>
2
<span lang="en-us">
</span>
</sub>
=f
<span lang="en-us">
</span>
(f
<span lang="en-us">
</span>
(R)), x
<sub>
3
<span lang="en-us">
</span>
</sub>
=
<span lang="en-us">
</span>
f
<span lang="en-us">
</span>
(f
<span lang="en-us">
</span>
(f(R))) и т.д. 101 раз. Первые 100 вычисленных
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
значений 
<span lang="en-us">
x
<sub>
1
</sub>
</span>
, х
<sub>
<span lang="en-us">
2
</span>
</sub>
, . . , x
<sub>
<span lang="en-us">
100
</span>
</sub>
 передаются Антону в качестве списка паролей, 
который он должен хранить в тайне. A x
<sub>
101
</sub>
 запоминается на сервере.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Теперь, когда Антон захочет зарегистрироваться для работы на сервере, ему 
достаточно ввести свое имя и число х
<sub>
100
</sub>
. Сервер вычислит f(x
<sub>
100
</sub>
) и сравнит 
его с х
<sub>
101
</sub>
. В случае совпадения Антону будет разрешен доступ к серверу, который 
затем заменит х
<sub>
101
</sub>
 на х
<sub>
100
</sub>
. А Антон вычеркнет х
<sub>
101
</sub>
 из своего списка паролей.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">В следующий раз, когда Антон снова захочет получить доступ к серверу, он 
найдет в списке паролей следующее по порядку не зачеркнутое значение х
<sub>
<span lang="en-us">
j
</span>
</sub>
.
<span lang="en-us">
</span>
Сервер вычислит f(x
<sub>
j
</sub>
) и сравнит с запомненным X
<sub>
j+
<span lang="en-us">
1
</span>
</sub>
.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Злоумышленник Зиновий, взломавший сервер, все равно не сможет узнать 
очередной пароль Антона 
<span lang="en-us">
x
</span>
<sub>
j 
</sub>
по хранимому на сервере значению x
<sub>
j+l,
</sub>
 поскольку 
функция f является однонаправленной. По той же самой причине. даже если Зиновий 
перехватит 
<span lang="en-us">
x
</span>
<sub>
j
</sub>
, это позволит ему зарегистрироваться под именем Антона всего 
лишь один раз. А значения x
<sub>
<span lang="en-us">
1
</span>
</sub>
,
<span lang="en-us">
 
x
<sub>
2
</sub>
,
</span>
<span lang="en-us">
...
</span>
 , х
<sub>
j
<span lang="en-us">
-1
</span>
</sub>
так и останутся для Зиновия тайной за 
семью печатями при условии, что Антон достаточно ответственно относится к 
хранению списка паролей, полученного
<span lang="en-us">
</span>
им с сервера.
</font></p>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
<b>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Аутентификация при помощи криптосистем с открытым ключом
</font></p>
</b>
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Ни &quot;изюминки&quot;, ни периодически сменяемый пароль не гарантируют защиту от 
злонамеренных действий Петра, перехватывающего все сообщения Антона, которые тот 
пересылает по линии связи, соединяющей его с сервером. Решить эту проблему помогает применение криптографии с открытым ключом.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Предполагается, что на сервере имеется 
файл, в котором хранятся открытые
<span lang="en-us">
</span>
ключи всех пользователей. В первом 
приближении криптографический протокол, 
который позволяет производить аутентификацию пользователей выглядит так:
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">1. Сервер генерирует случайную битовую строку и посылает ее Антону.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">2.
<i>
</i>
Антон шифрует эту строку при помощи своего 
тайного ключа и отсылает обратно на сервер.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">3. На сервере производится расшифрование 
сообщения, пришедшего от&nbsp; Антона, с помощью его открытого ключа.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">4. Если полученный в результате открытый текст идентичен случайной битовой строке, ранее посланной 
Антону, последний получает доступ к серверу.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Поскольку только Антон знает свой тайный ключ, никто не сможет выдать себя за 
Антона. Этот тайный ключ, скорее всего, представляет собой длинную битовую 
строку, которую очень трудно воспроизводить по памяти, и
</font>
<font face="Verdana, Arial, Helvetica, sans-serif">
</font>
<font face="Verdana, Arial, Helvetica, sans-serif" size="3">
поэтому в распоряжении Антона должен быть интеллектуальный терминал. надежно 
защищенный от взлома и способный автоматически осуществлять набор требуемого 
тайного ключа при шифровании сообщений. Однако несмотря на это дополнительное 
условие, важнее всего то, что тайный ключ Антона не требуется передавать на 
сервер ни под каким видом. Следовательно, для надежной аутентификации 
пользователей совсем не обязательно наглухо защищать от подслушивания канал 
связи, соединяющий терминал Антона с сервером. Да и информация о пользователях, 
хранимая на сервере, может быть безо всякой опаски сделана доступной для всех, 
кто пожелает с ней ознакомиться.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Конечно, со стороны Антона глупо шифровать на своем тайном ключе произвольную 
битовую последовательность, причем вне зависимости от ее происхождения. Поэтому 
на практике для аутентификации пользователей обычно используется более сложный 
криптографический протокол:
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">1. Антон производит некоторые специальные вычисления на основе предварительно 
сгенерированной им случайной битовой последовательности и своего тайного ключа. 
Затем он отсылает вычисленные им значения на сервер.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">2. Сервер посылает Антону случайную битовую последовательность, отличную от 
той, которая была задействована Антоном на шаге 1.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">3. Антон производит некоторые специальные вычисления на основе обеих 
случайных битовых последовательностей (сгенерированной им самим, а также 
полученной с сервера) и своего тайного ключа. Затем он отсылает вычисленные 
значения на сервер.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">4. На сервере производятся некоторые специальные вычисления на основе 
присланных Антоном значений и его открытого ключа, чтобы убедиться в том, что 
именно он является обладателем соответствующего тайного ключа.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">5. Если проверка дает положительный результат, Антону разрешается доступ к 
серверу.
</font></p>
<p>
<font  face="Verdana, Arial, Helvetica, sans-serif">Если Антон, в свою очередь, не доверяет серверу в такой же степени, в какой 
сервер не доверяет ему, то он может потребовать, чтобы сервер аналогичным 
образом &quot;удостоверил свою личность&quot;, воспользовавшись тем же самым протоколом.
</font></p>
</font>
<table width="14%" border="0" cellspacing="0">
<tr>
<td width="9%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="Index4.htm">
<img src="Back.gif" border="0" width="73" height="22">
</a>
</font>
</td>
<td width="45%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="../index.html">
<img src="Menu.gif" border="0" width="73" height="22">
</a>
</font>
</td>
<td width="46%">
<font face="Verdana, Arial, Helvetica, sans-serif">
<a href="Index6.htm">
<img src="For.gif" border="0" lowsrc="Index4.htm" width="73" height="22">
</a>
</font>
</td>
</tr>
</table>
</body>
</html>
