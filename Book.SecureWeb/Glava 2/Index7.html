<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<link rel="stylesheet" href="../STYLE.css">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><a href="Index6.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index8.html"><img SRC="For.gif" BORDER=0 ></a></td>
  </tr>
</table>

 
<br>
<table width="100%" border="0">
  <tr>
    <td class="Text_n">
 
<p class="Tit_CN">

Активное исследование стека</P>

<p class="Text_n">
Прежде чем перейти к рассмотрению возможностей утилит nmap и queso, необходимо вкратце пояснить, в чем же состоит суть исследования стека TCP/IP. Исследование стека (stack fingerprinting) — это очень мощная технология, позволяющая быстро определить тип и версию операционной системы узла с высокой степенью вероятности. Очевидно, что разные разработчики по-разному подходят к реализации стека TCP/IP. В частности, многие разработчики по-своему трактуют рекомендации документов RFC, что впоследствии проявляется в логике работы тех или иных сетевых служб. Таким образом, зная о существующих различиях и проверив реакцию служб изучаемой системы на различные ситуации, можно практически однозначно определить тип и версию соответствующей операционной системы. Для достижения максимальной достоверности при исследовании стека требуется по крайней мере один порт, находящийся в режиме ожидания запросов. С помощью утилиты nmap можно выдвинуть предположение об используемой операционной системе даже при отсутствии таких портов, однако степень его достоверности в этом случае будет невысокой. Полное описание процесса исследования стека можно найти в статье Федора (Fyodor), впервые публикованной в журнале Phrack
Magazine.
<br>

Ниже приведен перечень тестов, которые можно использовать в процессе исследования стека для определения типа и версии операционной системы.
<br>
<ul>
  <li>&nbsp;<span class="Text_b">Передача пакетов FIN (FIN probe)</span>. Пакет FIN отсылается в открытый порт. Как уже упоминалось, согласно документу RFC 793 исследуемая система не должна отвечать на такое сообщение. Однако многие реализации стека (например, Windows NT) отвечают на них, отправляя пакет
    FIN/ACK.</li>
  <li>&nbsp;<span class="Text_b">Попытка установки флагов (bogus flag probe)</span>. Отсылается пакет SYN с установленным флагом в заголовке TCP, значение которого не определено спецификацией протокола. Некоторые операционные системы, например Linux, в ответном пакете устанавливают этот же флаг.</li>
  <li>&nbsp;<span class="Text_b">Изучение начальной последовательности (Initial Sequence Number (ISN)
    sampling)</span>. Основная задача этого теста — попытаться определить характерные признаки
    начальной последовательности, генерируемой узлом при получении запроса на установку соединения, которые характерны для той или иной реализации
    TCP.</li>
  <li>&nbsp;<span class="Text_b">Мониторинг бита фрагментации (&quot;don't fragment bit&quot;
    monitoring)</span>. Этот бит устанавливается некоторыми операционными системами для повышения производительности. Проверка данного бита может помочь в определении типа операционной системы, для которой характерно такое поведение.</li>
  <li>&nbsp;<span class="Text_b">Исходный размер окна TCP (TCP initial window
    size)</span>. Для некоторых реализаций стека протоколов TCP/IP данный параметр уникален, что способствует точности определения типа операционной системы.</li>
  <li>&nbsp;<span class="Text_b">Значение АСК (дек value)</span>. В различных реализациях стека IP по-разному задается значение поля АСК. В одних случаях возвращается полученный от вас номер последовательности, а в других — значение номера последовательности, увеличенное на 1.</li>
  <li>&nbsp;<span class="Text_b">Обработка сообщений об ошибках ICMP (ICMP error message
    quenching)</span>. Некоторые операционные системы следуют рекомендациям документа RFC 1812
    (<span class="Text_b">www. ietf.org/rfc/rfcl812.txt</span>) и ограничивают скорость передачи сообщений об ошибках. Поэтому, отправляя UDP-пакеты на какой-либо порт (обычно с большим номером), вполне реально измерить количество сообщений об ошибках, поступившее за определенный период, и определить таким образом тип операционной системы.</li>
  <li>&nbsp;<span class="Text_b">Измерение длины сообщений ICMP (ICMP message
    quoting)</span>. При возникновении ошибок ICMP разными операционными системами передаются сообщения различной длины. Проанализировав полученное сообщение, можно сделать некоторые предположения об исследуемой операционной системе.</li>
  <li><span class="Text_b">&nbsp;Проверка целостности ответных сообщений об ошибках ICMP (ICMP error message-echoing
    integrity)</span>. В некоторых реализациях стека используется изменение заголовка IP при возврате сообщений об ошибках ICMP. Проверив тип изменений, внесенных в заголовок, можно сделать некоторые предположения об операционной системе исследуемого узла.</li>
  <li>&nbsp;<span class="Text_b">Тип службы (TOS — type of service)</span>. Можно проверять поле TOS для сообщений &quot;ICMP port unreachable&quot; (порт недоступен). В большинстве реализаций это поле имеет значение 0, однако иногда используются и другие значения.</li>
  <li>&nbsp;<span class="Text_b">Обработка фрагментации (fragmentation
    handling)</span>. Как отмечают Томас Пташек (Thomas Ptacek) и Тим Ньюсхам (Tim Newsham) в своей известной статье Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection (http://www. clark.net/~roesch/idspaper.html), различные стеки обрабатывают перекрывающиеся сообщения по-разному. При сборке фрагментированньк пакетов некоторые стеки записывают новые данные поверх старых и наоборот. Проверив, каким образом были собраны тестовые пакеты, можно сделать предположение об исследуемой операционной системе.</li>
  <li>&nbsp;<span class="Text_b">Параметры TCP (TCP options)</span>. Параметры TCP определены в документе RFC 793 и недавно изданном RFC 1323
    (<span class="Text_b">www.ietf.org/rfc/rfcl323.txt</span>). Нововведения, описанные в RFC 1323, нашли отражение только в самых последних реализациях стеков. Отправляя пакет с набором различных параметров, таких как по operation, maximum segment size, window scale factor, timestamp и так далее, можно сделать вывод о типе и версии операционной системы.</li>
</ul>

Для того чтобы воспользоваться утилитой nmap и выполнить все перечисленные тесты (за исключением обработки фрагментации и обработки сообщений об ошибках ICMP), достаточно указать в командной строке параметр -о. Давайте посмотрим, как будет выглядеть полученный результат.
<br>
<p class="Code">
[tsunami] <span class="Text_b">nmap -0192.168.1.10</span><br>
Starting nmap V. 2.53 by fyodor@insecure.org<br>
Interesting ports on shadow (192.168.1.10) :<br>
Port    State Protocol  Service<br>
7       open tcp       echo<br>
9      open tcp       discard<br>
13      open tcp       daytime<br>
19     open tcp       chargen<br>
21     open tcp       ftp<br>
22     open tcp       ssh<br>
23      open tcp       telnet<br>
25     open tcp       smtp<br>
37      open tcp       time<br>
111     open tcp       sunrpc<br>
512    open tcp       exec<br>
513     open tcp       login<br>
514    open tcp       shell<br>
2049   open tcp       nfs<br>
4045    open tcp        lockd<br>
TCP Sequence Prediction: Class=randorn positive increments<br>
Difficulty=26590 (Worthy challenge)<br>
Remote operating system guess: Solaris 2.5, 2.51<br>
</p>

Как видно, при включении режима исследования стека утилиты nmap можно легко получить достаточно точное определение типа и версии операционной системы. Даже если на изучаемом узле не открыто ни одного порта, утилита nmap поможет сделать довольно точное предположение об используемой операционной системе.
<br>
<p class="Code">
[ tsunami]# <span class="Text_b">nmap -p80 -0 10.10.10.10</span><br>
Starting nmap V. 2.53 by fyodor@insecure.org<br>
Warning:  No ports found open on this machine,<br> OS detection will be<br>
MUCH less reliable<br>
No ports open for host (10.10.10.10)<br>
Remote OS guesses: Linux 2.0.27 - 2.0.30, Linux 2.0.32-34,<br>
Linux 2.0.35-36, Linux 2.1.24 PowerPC,<br> Linux 2.1.76, Linux 2.1.91 - 2.1.103,<br>
Linux 2.1.122 - 2.1.132; 2.2.0-prel - 2.2.2, Linux 2.2.0-pre6 - 2.2.2-ac5<br>
Nmap run completed -- 1 IP <br>address (1 host up) scanned in 1 second<br>
</p>

Как видно из приведенного листинга, утилита nmap даже без открытых портов, правильно определила операционную систему Linux.
<br>

Одной из примечательных особенностей утилиты nmap является то, что листинг сигнатур хранится в отдельном файле с именем nmap-os-fingerprints. При появлении каждой новой версии утилиты этот файл также обновляется, и на момент написания данной книги в нем содержались сотни сигнатур. Если вы хотите добавить новые сигнатуры и повысить таким образом эффективность утилиты nmap, обратитесь ПО адресу
<span class="Text_b">http://www.insecure.org:80/cgi-bin/nmap-submit.cgi</span>.
<br>

Хотя на момент написания данной книги утилита nmap, по-видимому, позволяет наиболее точно выполнить исследование стека TCP/IP, она, тем не менее, является далеко не первой программой, в которой реализована соответствующая технология. До того как Федор встроил в утилиту nmap средства определения операционной системы, для этих же целей уже была создана утилита queso
(<span class="Text_b">http://www.apostols.org/projectz/</span>). Необходимо отметить, что утилита queso не позволяет выполнять сканирование портов и может определять тип операционной системы только при наличии в исследуемой системе открытого порта (по умолчанию используется порт 80). Если порт 80 закрыт, необходимо задать другой открытый порт, как показано в следующем примере, в котором с помощью утилиты queso осуществляется попытка определить тип операционной системы через порт 25.&nbsp;
<br>
<p class="Code">
[tsunami]   <span class="Text_b">queso  10.10.10.20:25</span><br>
10.10.10.20:25    * Windoze 95/98/NT<br>
</p>
<P align="center">
<span class="Text_b">Контрмеры: защита от определения операционной системы</span></P>
<br>
<P align="center">
<span class="Text_b">
Обнаружение попыток определения операционной системы</span></P>
<br>
<p class="Text_n">
Многие из упоминавшихся выше средств выявления сканирования с успехом могут служить и для обнаружения попыток определения типа операционной системы, Хотя они не проинформируют вас о том, что выполнялось специальное сканирование с помощью утилиты nmap или queso, с их помощью все же удастся распознать сам факт такого особого сканирования, например с установкой флага SYN.
<br>
<P align="center">
<span class="Text_b">
Предупреждение попыток определения операционной системы</span></P>
<br>
<p class="Text_n">
Хотелось бы посоветовать какое-нибудь средство, позволяющее противодействовать попыткам определения операционной системы, однако, к сожалению, вынуждены констатировать, что решить эту проблему весьма непросто. Конечно, можно изменить исходный код операционной системы (естественно, если он имеется в вашем распоряжении) или поменять ее параметры, влияющие на характеристики стека, однако такое вмешательство может значительно изменить функциональность ОС. Например, в системе FreeBSD 4.x имеется параметр ядра TCP_DROP_SYNFIN, который можно применить для игнорирования пакетов SYN+FIN, используемых утилитой nmap в целях исследования стека. Установка этого параметра поможет пресечь попытки определения типа операционной системы, однако в то же время нарушит поддержку RFC 1644 (TCP Extensions for Transactions).
<br>

Вместо этого мы предлагаем создавать такие сети, в которых сканированию могли бы подвергнуться лишь надежные и хорошо защищенные proxy-серверы и брандмауэры, а не компьютеры внутренней сети. В этом случае, даже если взломщику и удастся разведать тип операционной системы того или иного узла, проникновение через устройства защиты будет значительно затруднено.
<br>
<P align="center">
<span class="Text_b">
Пассивное определение операционной системы</span></P>
<br>
<p class="Text_n">
Из предыдущих разделов видно, насколько эффективными оказываются средства активного исследования стека, такие как утилиты nmap и queso. Важно не забывать о том, что рассмотренные выше приемы являются активными по своей природе. При этом для определения специфических особенностей сетевого стека и используемой операционной системы каждому узлу нужно передавать тестовые пакеты. Поскольку все активные методы предполагают передачу пакетов, системам выявления вторжений относительно просто выявить все предпринимаемые попытки идентификации операционной системы. Другими словами, активное исследование является далеко не самым скрытым методом, к которому может прибегнуть взломщик.
<br>


</p></td>
  </tr>
</table>
<br>
<table BORDER=0  COLS=3 WIDTH="11%" >
  <tr> 
   <td><a href="Index6.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index8.html"><img SRC="For.gif" BORDER=0 ></a></td>
   
  </tr>
</table>
</body>
</html>
