<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<link rel="stylesheet" href="../STYLE.css">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><a href="Index1.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index3.html"><img SRC="For.gif" BORDER=0 ></a></td>
  </tr>
</table>

 
<br>
<table width="100%" border="0">
  <tr>
    <td class="Text_n">
 
<p class="Tit_CN">
Контрмеры: защита от прослушивания сети</P>

<p class="Text_n">
Поскольку прослушивание сети в лучшем случае может вызывать раздражение, то очень важно выявлять все попытки таких действий. В зависимости от принятой в организации политики обеспечения безопасности можно также заблокировать прохождение пакетов, передаваемых при ping-прослушивании. В этом разделе рассматриваются обе возможности.
<br>
<P align="center">
<span class="Text_b">
Выявление факта прослушивания</span></P>
<br>
<p class="Text_n">
Как уже говорилось, ICMP- и TCP-прослушивание является общепринятым методом исследования сети перед непосредственной попыткой проникновения в сеть. Поэтому выявление факта прослушивания очень важно с точки зрения возможности получения информации о потенциальном месте проникновения и источнике угрозы. Один из основных методов выявления прослушивания состоит в использовании сетевой программы выявления вторжений, такой как Network Flight Recorder (NFR), или программы, установленной на исследуемом взломщиком узле. Ниже приведен алгоритм, который можно реализовать в программе, предназначенной для выявления факта прослушивания.
<br>
<p class="Code">
#  Обнаружение  прослушивания с помощью ICMP/Ping<br>
#  Автор — Стюарт Мак-Клар   (Stuart McClure)<br>
# Эта программа предназначена для выявления<br> ping-сканера,  изучающего вашу сеть<br>
#  Для  получения наилучших результатов<br>
#  установите  нужные  значения maxtime  и maxcount.<br>
ping_schema  =   library_schema::new(1,[&quot;time&quot;, &quot;ip&quot;,<br> &quot;ip&quot;,&quot;ethmac&quot;, &quot;ethmac&quot; ],<br>
scope());<br>
count  =   0;<br>
maxtime =10;   # Время в секундах<br>
maxcount =5;   #  Количество ICMP-запросов ECHO или запросов ARP,<br>
               # которое рассматривается как допустимое<br>
 dest = 0;<br>
 source = 0;<br>
 ethsrc = 0;<br>
 ethdst = 0;<br>
 time = 0;<br>
filter icmp_paskets icmp( )<br>
{<br>
if (icmp.type == 0x08)   # Проверка на ICMP-пакеты ECHO.<br>
{<br>
if ((source == ip.src) &amp;&amp; (dest != ip.dst))   # Попался!<br>
{<br>
count = count + 1;<br>
time = system.time;<br>
}<br>
else<br>
count = 1; <br>
dest = ip.dest; <br>
source = ip.src; <br>
ethsrc = eth.src; <br>
ethdst = eth.dst;<br>
} .<br>
 on tick = timeout ( sec: maxtime, repeat) call checkit; <br>
 }<br>
func checkit;<br>
{<br>
if (count &gt;= maxcount) <br>
{<br>
echo (&quot;Обнаружен.ping-сканнер! Время: &quot;, time, &quot;\n&quot;); <br>
record system.time, source, dest, eth.src, eth.dst<br>
to the_record_ping; count = 0; dest = 0; <br>
} else<br>
{<br>
dest = 0; count = 0;<br>
}<br>
return; <br>
}<br>
the_record_ping=recorder(&quot;bin/histogram <br>
packages/sandbox/pingscan.cfg&quot;,<br>
&quot;ping_schema&quot; );<br>
</p>

Что касается защиты на уровне отдельного узла, для этого можно с успехом применять утилиты UNIX, которые позволяют выявлять и регистрировать попытки прослушивания. Если, просматривая файл журнала, созданный такой утилитой, вы обнаружите массированные ICMP-запросы ECHO, исходящие из одной и той же сети или от одного и того же узла, это, скорее всего, означает, что вашу сеть кто-то исследует. На такие факты необходимо обращать самое пристальное внимание, так как после изучения сети обычно предпринимается реальная попытка проникновения.
<br>

К сожалению, найти аналогичные утилиты для платформы Windows достаточно сложно. Одним из немногих бесплатных или условно бесплатных пакетов, заслуживающих внимания, является Genius 3.1. Краткую информацию о новой версии этого программного продукта можно найти по адресу
<span class="Text_b"> http://softseek.com/Internet/ General/Review_20507_index.html</span>, а более подробные сведения о нем и загружаемый файл содержатся по адресу
<span class="Text_b">http: //www.indiesoft.com/</span>. Эта программа не позволяет регистрировать попытки ping-прослушивания, а предназначена лишь для выявления TCP-сканирования определенного порта. Среди коммерческих пакетов аналогичного назначения можно отметить BlackICE от компании Network ICE
(<span class="Text_b">http://www.networkice.com</span>). Этот программный продукт позволяет не только обнаруживать факты JCMP- и TCP-прослушивания, но и решать много других задач. В табл. 2.1 перечислены некоторые дополнительные утилиты, которые могут значительно облегчить выявление попыток прослушивания вашей сети.
<br>
<P class="text_n"><span class="label">
Таблица 2.1.Некоторые утилиты UNIX, предназначенные для зашиты
от прослушивания на уровне узла
</span></p>
<TABLE  BORDER="1" CELLSPACING="2" CELLPADDING="2" WIDTH="100%" bordercolordark="#000000"
bordercolorlight="#000000" class="border" >
<TR >
<TD   >


<span class="Text_b">
Программа</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Ресурс</span>
<br>

</TD>
</TR>
<TR >
<TD    >


Scanlogd
<br>

</TD>
<TD    >


<span class="Text_b">
http : //www.openwall.com/scanlogd</span>
<br>

</TD>
</TR>
<TR >
<TD    >


Courtney 1 .3
<br>

</TD>
<TD    >

<span class="Text_b">ftp://ciac.llnl.gov/pubс/сiac/sectools /unix</span>
<br>

</TD>
</TR>
<TR >
<TD    >


Ippl1.4.10
<br>

</TD>
<TD    >


<span class="Text_b">
http: //pltplp.net/ippl/</span>
<br>

</TD>
</TR>
<TR >
<TD    >


Protolog 1.0.8
<br>

</TD>
<TD    >


<span class="Text_b">http: //packet storm. securify.com/UNIX/loggers/protolog-1.0.8. tar.gz</span>
<br>

</TD>
</TR>
</TABLE>
<P align="center">
<span class="Text_b">
Предотвращение прослушивания</span></P>
<br>
<p class="Text_n">
Если обнаружение факта прослушивания имеет столь большое значение, то что тогда говорить о предупреждении таких попыток! Мы рекомендуем очень внимательно оценить, насколько важен для вашей организации обмен данными по протоколу ICMP между узлами вашей сети и Internet. Имеется много разнообразных типов сообщений ICMP, ECHO и ECHO_REPLY — лишь два из них. В большинстве случаев нет никакой необходимости разрешать обмен данными между узлами сети и Internet с использованием всех имеющихся типов сообщений. Практически все современные брандмауэры обладают возможностью отфильтровывать пакеты ICMP, поэтому единственная причина, по которой они могут проходить во внутреннюю сеть,— та или иная производственная необходимость. Даже если вы твердо убеждены в том, что нельзя полностью заблокировать протокол ICMP, обязательно заблокируйте те типы сообщений, которые вам не нужны для работы. Как правило, вполне достаточно, чтобы с зоной DMZ можно было взаимодействовать посредством сообщений ECHO_REPLY, HOST UNREACHABLE И TIME EXCEEDED. Кроме того, с помощью списка управления доступом (ACL — Access Control List) можно разрешить обмен сообщениями по протоколу ICMP только с несколькими IP-адресами, например, принадлежащими вашему провайдеру Internet. Это позволит провайдеру, при необходимости, проверить качество связи, но при этом проникновение посторонних извне в компьютеры, подключенные к Internet, будет значительно затруднено. Необходимо всегда помнить, что несмотря на удобство и мощь протокола ICMP с точки зрения диагностирования сетевых проблем, он с успехом может использоваться и для создания таких проблем. Разрешив неограниченный доступ по протоколу ICMP во внутреннюю сеть, вы тем самым предоставляете взломщикам возможность реализовать нападение типа DoS (например с помощью Smurf-метода). Более того, если взломщику удастся проникнуть в один из ваших компьютеров, он может через &quot;потайной ход&quot; в операционной системе с помощью таких программ, как loki, организовать скрытое тунеллирование данных, передаваемых по протоколу ICMP. Более подробная информация о loki приведена в журнале Phrack Magazine, том 7, выпуск 51 за 1 сентября 1997 года, статья
06(<span class="Text_b">http://phrack.infonexus.com/search.phtml?view&amp;article=p51-6</span>).
<br>

Другая интересная концепция, предложенная Томом Пташеком (Tom Ptacek) и перенесенная в среду Linux Майком Шифманом (Mike Schiffman) заключается в использовании процесса pingd. Демон pingd, запущенный на компьютере пользователя, обрабатывает все поступающие на данный компьютер запросы ICMP_ECHO и ICMP_ECHOREPLAY. Для реализации такого подхода нужно отказаться от поддержки обработки запроса ICMP_ECHO на уровне ядра и реализовать ее на уровне пользователя с помощью служебного процесса, обеспечивающего работу сокета ICMP. Таким образом, появляется возможность создания механизма управления доступом на уровне отдельного компьютера. Утилита pingd имеется в версии BSD
(<span class="Text_b">http://www.enteract.com/~tqbf/goodies.html</span>) и в системе Linux (<span class="Text_b">http://www.2600.net/phrack/p52-07.html</span>).
<br>
<P align="center">
<span class="Text_b">
Запросы IСМР</span></P>
<br>
<p class="Text_n">
Если говорить о возможностях протокола ICMP для сбора информации о сети, то прослушивание с помощью утилиты ping (или, другими словами, с помощью пакетов ECHO, пересылаемых по протоколу ICMP), — это только верхушка айсберга. Просто обмениваясь пакетами ICMP с интересующей вас системой, о ней можно получить любую информацию. Например, с помощью таких утилит UNIX, как icmpquery
(<span class="Text_b">http://packetstorm.securify.com/UNIX/scanners/icmpquery.с</span>) или icmpush
<span class="Text_b">(http://packetstorm.security.com/UNIX/scanners/icmpush22.tgz</span>), можно узнать системное время удаленного узла (т.е. часовой пояс, в котором он находится). Для этого нужно отправить по протоколу ICMP сообщение типа 13 (TIMESTAMP). Точно так же, обратившись к определенному устройству с ICMP-запросом типа 17 (ADDRESS MASK REQUEST), можно узнать маску подсети. Знание маски подсети сетевой карты позволяет определить все существующие подсети. Например, используя маску подсети, усилия можно сосредоточить на определенной подсети и избежать необходимости обращения к адресам рассылки широковещательных сообщений. Утилита icmpquery позволяет запрашивать как системное время, так и маску подсети.
<br>
<p class="Code">
icmpquery &lt;query&gt; [-B] [-f fromhost] [-d delay] [-T time] targets<br>
Здесь параметр query принимает одно из следующих значений:<br>
-t : ICMP-запрос системного времени (по умолчанию);<br>
-m : ICMP-запрос маски подсети.<br>
delay   — задержка между пакетами в миллисекундах,<br>
targets — список имен или адресов исследуемых узлов,<br>
time       — время в секундах, в течение которого следует ожидать<br>
           отклика. По умолчанию используется значение 5 с.<br>

-В         — включение режима широковещательной рассылки. В этом режиме<br>
           утилита ожидает в течение периода, определенного параметром<br>
           time, а затем выводит отчет о поступивших ответах.<br>
           Если вы используете модем, установите<br> значения параметров -d и -Т большими,<br>
           чем установленные по умолчанию.<br>
</p>

Например, чтобы с помощью icmpquery узнать системное время маршрутизатора, воспользуйтесь следующей командой.
<br>
<p class="Code">
[tsunami] icmpquery -t 192.168.1.1<br>
192.168.1.1 :  11:36:19<br>
</p>

Запрос на получение маски подсети выглядит следующим образом.
<br>
<p class="Code">
[tsunami] icmpquery -m 192.168.1.1<br>
192.168.1.1 :  OxFFFFFFEO<br>
</p>

<p class="Prim">
Далеко не все маршрутизаторы/узлы отвечают на ICMP-запросы TIMESTAMP или NETMASK. Поэтому с помощью утилит icmpquery и icmpush на различных узлах можно получить разные результаты.
</p>
<P align="center">
<span class="Text_b">Контрмеры: защита от ЮМР-запросов</span></P>
<br>
<p class="Text_n">
Одним из самых лучших методов защиты является блокирование
IOМР-запросов тех типов, которые способствуют разглашению информации о сети за ее пределами. Как минимум, на пограничном маршрутизаторе необходимо заблокировать прохождение во внутреннюю сеть пакетов TIMESTAMP (ICMP-сообщение тип 13) и ADDRESS MASK (тип 17). Например, если в качестве пограничного маршрутизатора используется маршрутизатор Cisco, запретите ему отвечать на указанные запросы, добавив следующие строки в список управления доступом.
<br>
<p class="Code">
access-list  101 <br> deny  icmp  any  any  13  ! timestamp request<br>
access-list  101  deny  icmp <br> any  any  17  ! address mask request<br>
</p>

Для выявления рассмотренных выше видов деятельности можно также воспользоваться сетевыми системами выявления вторжений V(NIDS), например, программой Марти Рош (Marty Roach)
(<span class="Text_b">http://www.snort.org/</span>). При выявлении такого типа вторжений будет выведена следующая информация.
<br>
<p class="Code">
[**] PING-ICMP Timestamp [**]<br>
05/29-12:04:40.535502 192.168.1.10 -&gt; 192.168.1.1<br>
ICMP TTL:255 TOS:0x0 ID:4321<br>
TIMESTAMP REQUEST<br>
</p>
<P align="center">
<span class="Text_b">   Сканирование портов</span></P>
<br>
<p class="Text_n">
С помощью ICMP- или TCP-прослушивания мы установили, какие компьютеры исследуемой сети подключены к Internet. Кроме того, вся требуемая информация собрана также и с использованием запросов ICMP. Теперь можно перейти к этапу сканирования портов этих компьютеров. Сканирование портов (port scanning) — это процесс пробного подключения к портам TCP и UDP исследуемого компьютера с целью определения, какие службы на нем запущены и обслуживаются ли ими соответствующие порты. Обслуживаемые порты могут находиться в работающем состоянии или в состоянии ожидания запроса (listening mode). Определение портов, находящихся в состоянии ожидания запроса, — этап, имеющий определяющее значение для последующего выяснения типа используемой операционной системы, а также работающих на компьютере прикладных программ. Активные службы, находящиеся в состоянии ожидания, могут предоставить взломщику возможность получить несанкционированный доступ. Это обычно происходит в том случае, когда система безопасности компьютера не настроена должным образом или в программном обеспечении имеются хорошо известные изъяны в системе защиты. За последние несколько лет средства и методы сканирования портов были значительно усовершенствованы. Учитывая ограниченный объем книги, мы рассмотрим лишь самые популярные из них, с помощью которых можно получить значительную часть важной информации. Теперь мы уже не будем пытаться определить, подключен ли тот или иной компьютер к Internet, как это делалось ранее. Для упрощения задачи будем считать, что мы это уже установили однозначно и сосредоточимся лишь на методике выявления портов, находящихся в состоянии ожидания, или возможных точек проникновения в исследуемую систему.
<br>

При сканировании портов решается несколько задач, связанных с изучением системы защиты соответствующего узла. Среди этих задач можно выделить следующие.
<br>
<ul>
  <li>&nbsp;Идентификация TCP- и UDP-служб, запущенных на исследуемом узле.</li>
  <li>&nbsp;Идентификация типа операционной системы, установленной на исследуемом узле.&nbsp;</li>
  <li>&nbsp;Идентификация приложений или версий определенных служб.</li>
</ul>

<br>


</p></td>
  </tr>
</table>
<br>
<table BORDER=0  COLS=3 WIDTH="11%" >
  <tr> 
   <td><a href="Index1.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index3.html"><img SRC="For.gif" BORDER=0 ></a></td>
   
  </tr>
</table>
</body>
</html>
