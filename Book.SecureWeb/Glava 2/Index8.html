<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<link rel="stylesheet" href="../STYLE.css">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><a href="Index7.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index9.html"><img SRC="For.gif" BORDER=0 ></a></td>
  </tr>
</table>

 
<br>
<table width="100%" border="0">
  <tr>
    <td class="Text_n">
 
<p class="Tit_CN">

Пассивное исследование стека</P>

<p class="Text_n">
Основные принципы пассивного исследования стека аналогичны концепциям, лежащим в основе его активного исследования. Однако в данном случае вместо передачи пакетов для определения используемой операционной системы взломщик осуществляет мониторинг сетевого трафика. Таким образом, наблюдая за сетевым трафиком между различными компьютерами, можно определить тип и версию удаленной операционной системы. Большие исследования в этой области были проведены Ланцом Спитзнером (Lance Spitzner). На их основе была написана книга, которую можно найти по адресу
<span class="Text_b">http://www.enteract.com/~lspitz/finger.html</span>. Кроме ТОГО, по адресу
<span class="Text_b"> http://www.subterrain.net/projects/siphon </span> можно также найти утилиту siphon, предназначенную для пассивного исследования портов и идентификации операционной системы. Теперь познакомимся с тем, как же выполняется пассивное исследование стека.
<br>
<P align="center">
<span class="Text_b">
Параметры, используемые для пассивного исследования стека</span></P>
<br>
<p class="Text_n">
Для определения типа и версии операционной системы можно использовать самые разнообразные признаки. Однако сейчас мы ограничимся рассмотрением лишь нескольких атрибутов, связанных с сеансом сетевого взаимодействия с помощью протокола
TCP/IP.
<br>
<ul>
  <li>&nbsp;атрибутов <span class="Text_b"> TTL</span> (Time-to-Live — время жизни). Устанавливает ли операционная система значение TTL для исходящих пакетов?</li>
  <li>&nbsp;<span class="Text_b">Windows Size</span> (размер окна). Какой размер окна используется?</li>
  <li>&nbsp;<span class="Text_b">DF</span> (Don't Fragment — бит фрагментации). Устанавливается ли операционной системой признак
    DF?</li>
  <li>&nbsp;<span class="Text_b">TOS</span> (Type-of-Service — тип службы). Устанавливается ли операционной системой значение TOS. Если да, то какое?</li>
</ul>

Проанализировав каждый из атрибутов и сравнив полученные результаты со значениями из имеющейся базы данных, можно определить удаленную операционную систему. Поскольку этот метод не гарантирует получения правильного ответа на основе каждого из атрибутов в отдельности, для получения более надежных результатов атрибуты можно комбинировать. Именно такой подход и используется утилитой siphon.
<br>

Вот как работает описанный метод. Если с помощью утилиты telnet установить удаленное соединение между узлами 192 .168 .1.10 и 192 .168 .1.11 , то с использованием утилиты siphon можно определить тип удаленной операционной системы.
<br>

<span class="Text_b">
[shadow]# telnet 192.168.1.11</span>
<br>

С помощью нашей любимой утилиты snort можно частично просмотреть пакеты, передаваемые в процессе сетевого взаимодействия.
<br>
<p class="Code">
06/04-11:23:48.297976 192.168.1.11:23 -&gt; 192.168.1.10:2295<br>
TCP TTL:255 TOS:OxO 10:58934  DF<br>
**S***A* Seq: OxD3B709A4   Ack: OxBE09B2B7   Win: 0x2798<br>
TCP Options =&gt; NOP NOP TS: 9688775 9682347 NOP WS: 0 MSS: 1460<br>
</p>

При этом видно, что упоминавшиеся выше атрибуты принимают следующие значения:
<br>
<ul>
  <li>&nbsp;TTL= 255</li>
  <li>&nbsp;Размер окна = 2798</li>
  <li>&nbsp;Бит DF = Yes A TOS = 0</li>
</ul>

Теперь обратимся к базе данных утилиты siphon — файлу osprints.conf:&nbsp;
<br>
<p class="Code">
 [shadow]f grep -i Solaris osprints.conf<br>
# Window:TTL:DF:Operating System DF = 1 for ON, 0 for OFF.<br>
2328:255:l:Solaris 2.6 - 2.7<br>
2238:255:l:Solaris 2.6 - 2.7<br>
2400:255:l:Solaris 2.6 - 2.7<br>
2798:255:l:Solaris 2.6 - 2.7<br>
FE88:255:l:Solaris 2.6 - 2.7<br>
87CO:255:l:Solaris 2.6 - 2.7<br>
FAFO:255:0:Solaris 2.6 - 2.7<br>
FFFF:255:1:Solaris 2.6-2.7<br>
</p>

Из приведенного фрагмента видно, что в четвертой записи содержатся те же значения, которые были получены с использованием утилиты snort. Таким образом, с помощью утилиты siphon можно точно определить исследуемую операционную систему.&nbsp;
<br>
<p class="Code">
[crush]#  <span class="Text_b">siphon -v -i xl0 -о fingerprint.out</span><br>
Running on: 'crush' running FreeBSD 4.0-RELEASE on a(n) i386<br>
Using Device: xlO<br>
Host Port .  TTL DF Operating System 192.168.1.11   23  255  ON Solaris 2.6 - 2.7<br>
</p>

Итак, в качестве удаленной была определена система Solaris 2.6. И это .не вызвало особых проблем.
<br>

Пассивное исследование стека взломщик может использовать для выбора потенциальных жертв. Для этого достаточно понаблюдать за соответствующим Web-узлом и проанализировать сетевой трафик либо воспользоваться утилитой siphon. Несмотря на то что описанный метод является достаточно эффективным, он все же имеет некоторые ограничения. Во-первых, в приложениях, генерирующих свои собственные пакеты (например, шпар), не применяются те же признаки, что и самой операционной системой. Поэтому полученные результаты могут оказаться неточными. Во-вторых, на удаленном узле можно без проблем изменить атрибуты соединения.&nbsp;
<br>
<p class="Code">
Solaris: ndd -set /dev/ip ip_def_ttl 'число'<br>
Linux: echo 'число' &gt; /proc/sys/net/ipv4/ip_default_ttl<br>
NT:<br>
HKEY_LOCAL_MACHINE\System\CurrentControlSet\<br>Services\Tcpip\Parameters<br>
</p>
<P align="center">
<span class="Text_b">Контрмеры: защита от пассивного определения операционной системы</span></P>
<br>
<p class="Text_n">
Для защиты от пассивного определения операционной системы можно использовать приемы, описанные в разделе &quot;Контрмеры: Защита От Определения Операционной Системы&quot;.
<br>


</p></td>
  </tr>
</table>
<br>
<table BORDER=0  COLS=3 WIDTH="11%" >
  <tr> 
   <td><a href="Index7.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index9.html"><img SRC="For.gif" BORDER=0 ></a></td>
   
  </tr>
</table>
</body>
</html>
